## Multithreading

+ [1. Чем отличается процесс от потока?](#1-Чем-отличается-процесс-от-потока)
+ [2. Каким образом можно создать поток?](#2-Каким-образом-можно-создать-поток)
+ [3. Как работают методы sleep, yield, wait, notify и notifyAll?](#3-Как-работают-методы-sleep-yield-wait-notify-и-notifyAll)
+ [4. Объясните следующие термины: монитор, мьютекс, критическая секция.](#4-Объясните-следующие-термины-монитор-мьютекс-критическая-секция)
+ [5. Как работает join?](#5-Как-работает-join)
+ [6. Что такое DeadLock? Приведите примеры.](#6-Что-такое-DeadLock-Приведите-примеры)
+ [7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.](#7-Назовите-различия-между-CollectionssynchronizedMapnew-HashMap-и-ConcurrentHashMap)
+ [8. Различия в интерфейсах Runnable и Callable.](#8-Различия-в-интерфейсах-Runnable-и-Callable)
+ [9. Различя между isInterrupted, interrupted.](#9-Различия-между-isInterrupted-interrupted)
+ [10. Что происходит при вызове Thread.interrupt()?](#10-Что-происходит-при-вызове-Threadinterrupt)
+ [11. Перечислите ВСЕ причины по которым может выскочить InterruptedException.](#11-Перечислите-ВСЕ-причины-по-которым-может-выскочить-InterruptedException)
+ [12. Назовите отличия synchronize{} и ReentrantLock.](#12-Назовите-отличия-synchronize-и-ReentrantLock)
+ [13. Приведите наиболее существенное отличие между CountDownLatch и Barrier.](#13-Приведите-наиболее-существенное-отличие-между-CountDownLatch-и-Barrier)
+ [14. Отличие Thread.start и Thread.run?](#14-Отличие-Threadstart-и-Threadrun)
+ [15. Объясните ключевое слово volatile.](#15-Объясните-ключевое-слово-volatile)
+ [16. Расскажите про приоритеты потока.](#16-Расскажите-про-приоритеты-потока)
+ [17. Что такое потоки-демоны?](#17-Что-такое-потоки-демоны)
+ [18. Назовите все возможные состояния потока.](#18-Назовите-все-возможные-состояния-потока)
+ [19. Что такое race condition?](#19-Что-такое-race-condition)
+ [20. Что такое Thread Local переменная?](#20-Что-такое-Thread-Local-переменная)
+ [21. Что такое FutureTask?](#21-Что-такое-FutureTask)
+ [22. Что такое Thread Pool?](#22-Что-такое-Thread-Pool)
+ [23. Что такое Semaphore?](#23-Что-такое-Semaphore)
+ [24. Чем отличается submit от execute у ExecutorServices?](#24-Чем-отличается-submit-от-execute-у-ExecutorServices)
+ [25. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?](#25-Чем-отличается-shutdown-от-shutdownNow-у-ThreadPoolExecutor)
+ [27. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.](#27-Как-создать-ThreadPool-у-ExecutorService-только-на-1-на-5-на-неограниченное-количество-потоков)
+ [28. Что такое ReadWriteLock?](#28-Что-такое-ReadWriteLock)
+ [29. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt и FutureTask.cancel.](#29-В-чём-отличие-Thread-от-FutureTask-В-чём-отличие-Threadinterrupt-и-FutureTaskcancel)
+ [30. Расскажите про шаблон проектирования Producer Consumer.](#30-Расскажите-про-шаблон-проектирования-Producer-Consumer)


## 1 Чем отличается процесс от потока

**Процесс** - это Отдельно запущенное приложение и у него есть своя область памяти (минимум 1 поток).
**Поток** - это паралельные нити выполнения внутри одного процесса которые разделяют общую память.

[к оглавлению](#Multithreading)

## 2 Каким образом можно создать поток

+ Создать потомка класса Thread и переопределить его метод run();
+ Создать объект класса Thread, передав ему в конструкторе экземпляр класса, реализующего интерфейс Runnable. 
Эти интерфейс содержит метод run(), который будет выполняться в новом потоке. 
Поток закончит выполнение, когда завершится его метод run().
+ Вызвать метод submit() у экземпляра класса реализующего интерфейс ExecutorService, 
передав ему в качестве параметра экземпляр класса реализующего интерфейс Runnable или Callable (содержит метод call(), в котором описывается логика выполнения).

[к оглавлению](#Multithreading)

## 3 Как работают методы sleep yield wait notify и notifyAll

+ sleep - усыпляет поток, не освобождает lock объект
+ wait - усыпляет поток, освобождает lock объект
+ notify - будит последний стоящий в очереди поток
+ notifyAll - будит все стоящие в очереди объекты
+ yield - это попытка уступить очередь потокам, решает jvm.

[к оглавлению](#Multithreading)

## 4 Объясните следующие термины: монитор мьютекс критическая секция

**Монитор, мьютекс (mutex)** – это средство обеспечения контроля за доступом к ресурсу. 
У монитора может быть максимум один владелец в каждый текущий момент времени. 
Следовательно, если кто-то использует ресурс и захватил монитор для обеспечения единоличного доступа, то другой, 
желающий использовать тот же ресурс, должен подождать освобождения монитора, 
захватить его и только потом начать использовать ресурс.

Удобно представлять монитор как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. 
Если не 0 – ресурс занят. Можно встать в очередь и ждать его освобождения.

В Java у каждого экземпляра объекта есть монитор, который контролируется непосредственно виртуальной машиной. 
Используется он так: любой нестатический synchronized-метод при своем вызове прежде всего пытается захватить монитор того объекта, 
у которого он вызван (на который он может сослаться как на this). Если это удалось – метод исполняется. 
Если нет – поток останавливается и ждет, пока монитор будет отпущен.

Монитор — это дополнительная «надстройка» над мьютексом. По сути, монитор в Java выражен с помощью слова synchronized

[к оглавлению](#Multithreading)

## 5 Как работает join

Когда поток вызывает join() для другого потока, текущий работающий поток будет ждать, пока другой поток, 
к которому он присоединяется, не будет завершён:

```java
    void join()        
    void join(long millis) 
    void join(long millis, int nanos) 
```

[к оглавлению](#Multithreading)

## 6 Что такое DeadLock Приведите примеры

Взаимная блокировка (deadlock) - явление при котором все потоки находятся в режиме ожидания. Происходит, когда достигаются состояния:

+ **Взаимная блокировка порядка синхронизации**
```java
public void transferMoney(Account fromAccount, Account toAccount, Amount amount) throws InsufficientFundsException {
	synchronized (fromAccount) {
		synchronized (toAccount) {
			if (fromAccount.getBalance().compareTo(amount) < 0)
				throw new InsufficientFundsException();
			else {
				fromAccount.debit(amount);
				toAccount.credit(amount);
			}
		}
	}
}
```
Данная блокировка вызвана тем, что синхронизация счетов может происходить в разном порядке. 
Соответственно, если ввести некоторый порядок на счетах (это некоторое правило, позволяющее сказать, что счет A меньше чем счет B), то проблема будет устранена.
+ **Взаимная блокировка между объектами.**
```java
class Plane {
	private Point location, destination;
	private final Dispatcher dispatcher;

	public Plane(Dispatcher dispatcher) {
		this.dispatcher = dispatcher;
	}
	public synchronized Point getLocation() {
		return location;
	}
	public synchronized void setLocation(Point location) {
		this.location = location;
		if (location.equals(destination))
		dispatcher.requestLanding(this);
	}
}

class Dispatcher {
	private final Set<Plane> planes;
	private final Set<Plane> planesPendingLanding;

	public Dispatcher() {
		planes = new HashSet<Plane>();
		planesPendingLanding = new HashSet<Plane>();
	}
	public synchronized void requestLanding(Plane plane) {
		planesPendingLanding.add(plane);
	}
	public synchronized Image getMap() {
		Image image = new Image();
		for (Plane plane : planes)
			image.drawMarker(plane.getLocation());
		return image;
	}
}
```

В результате, если самолет прибывает на место, в тот же момент, как кто-то решает получить карту может возникнуть взаимная блокировка. 
То есть, будут вызваны методы, getMap и setLocation, которые займут мониторы экземпляров Dispatcher и Plane соответственно. 
Затем метод getMap вызовет plane.getLocation (в частности для экземпляра Plane, который в данный момент занят), 
который будет ждать освобождения монитора для каждого из экземпляров Plane. 
В то же время в методе setLocation будет вызван dispatcher.requestLanding, при этом монитор экземпляра Dispatcher остается занят рисованием карты. 
Результат – взаимная блокировка.

+ **Ресурсная взаимная блокировка**. 
Безусловно, если код написан без каких-либо ошибок (примеры которых мы видели в предыдущих разделах), 
то взаимных блокировок в нем не будет. Но кто может поручиться, что его код написан без ошибок? 
Безусловно, тестирование помогает выявить значительную часть ошибок, но как мы уже видели ранее, 
ошибки в многопоточном коде нелегко диагностировать и даже после тестирования нельзя быть уверенным в отсутствии ситуаций взаимных блокировок. 
Можем ли мы как-то перестраховаться от блокировок? Ответ – да. Подобные техники применяются в движках баз данных, 
которым нередко необходимо восстанавливаться после взаимных блокировок (связанных с механизмом транзакций в БД).
                                     
Интерфейс Lock и его реализации доступные в пакете java.util.concurrent.locks позволяют попытаться занять монитор, 
связанный с экземпляром данного класса методом tryLock (возвращает true, если удалось занять монитор). 
Пусть у нас есть пара объектов реализующих интерфейс Lock и нам необходимо занять их мониторы так, чтоб избежать взаимной блокировки.

Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. Этого можно достичь, 
получая мониторы разделяемых ресурсов в определённом порядке и освобождая их в обратном порядке.

[к оглавлению](#Multithreading)

## 7 Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap

Оба являются синхронизированными версиями HashMap c различиями в функциональности и внутренней структуре. 
**ConcurrentHashMap** состоит из внутренних сегментов, которые могут рассматриваться как независимые HashMap’ы концептуально. 
Все эти сегменты могу быть заблокированы отдельными потоками выполняемыми одновременно. 
Таким образом несколько потоков могу одновременно получить/положить пары key-value из ConcurrentHashMap без блокирования/ожидания друг друга.
использует очень сложные методы для уменьшения необходимости синхронизации 
и обеспечения параллельного доступа для чтения несколькими потоками без синхронизации и, 
что более важно, предоставляет Iterator, который не требует синхронизации, 
и даже позволяет изменять Карту во время (хотя он **не гарантирует, будут ли возвращены элементы, вставленные во время итерации**).

**Из Collections.synchronizedMap()** мы получаем синхронизированную версию HashMap и доступ в блокировании образом. 
Это означает то что если несколько потоков пытаются получить доступ к synchronizedMap в одно и тоже время 
им будет позволено взять/положить пары key-value по одному синхронизированному образу.
они используют очень простую синхронизацию, а это означает, что только один поток может одновременно получить доступ к карте.
Это не большая проблема, когда у вас есть простые вставки и поиск (если вы не делаете это очень интенсивно), 
но **становится большой проблемой, когда вам нужно перебирать всю карту**, 
что может занять много времени для большой Карты. В то время как один поток делает это, все остальные должны ждать, 
хотят ли они вставлять или искать что-либо.


[к оглавлению](#Multithreading)

## 8 Различия в интерфейсах Runnable и Callable

+ Интерфейс Runnable появиля в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent;
+ Классы, реализующие интерфейс Runnable для выполнения задачи должны реализовывать метод run(). 
Классы, реализующие интерфейс Callable - метод call();
+ Метод Runnable.run() не возвращает никакого значения, Callable.call() возвращает объект Future, 
который может содержать результат вычислений;
+ Метод run() не может выбрасывать проверяемые исключения, в то время как метод call() может.

[к оглавлению](#Multithreading)

## 9 Различия между isInterrupted interrupted

Механизм прерывания работы потока в Java реализован с использованием внутреннего флага, известного как статус прерывания. 
Прерывание потока вызовом Thread.interrupt() устанавливает этот флаг.
 
Методы Thread.interrupted() и isInterrupted() позволяют проверить, является ли поток прерванным.
+ Когда прерванный поток проверяет статус прерывания, вызывая статический метод Thread.interrupted(), 
статус прерывания сбрасывается. Фактически, это еще и ограничивает возможность снять флаг прерывания у других тредов (нельзя "украсть" прерывание другого треда).

+ Нестатический метод isInterrupted() используется одним потоком для проверки статуса прерывания у другого потока, 
не изменяя флаг прерывания.

[к оглавлению](#Multithreading)

## 10 Что происходит при вызове Thread.interrupt()

Устанавливает флаг прерывания.

[к оглавлению](#Multithreading)

## 11 Перечислите ВСЕ причины по которым может выскочить InterruptedException

+ Поток прерван во время ожидания на мониторе
+ Поток прерван во время засыпания
+ Поток прерван во время захвата ReentrantLock через lockInterruptibly
+ Поток прерван во время ожидания в CountDownLatch через await
+ Поток прерван во время ожидания в CyclicBarrier через await
+ Поток прерван во время ожидания в Condition через await
+ Поток прерван во время захвата попытки в Semaphore через acquireUninterruptibly
+ Поток прерван во время получения значения в Future через get
+ Поток прерван во время обмена значенимя в Exchanger через exchange
+ Поток прерван во время блокирующих операций с BlockingQueue
+ Поток прерван во время работы с I/O через InterruptableChannel

В общем, почти любой блокирующий метод выбрасывает это исключение.

[к оглавлению](#Multithreading)

## 12 Назовите отличия synchronize{} и ReentrantLock

В Java 5 появился интерфейс Lock предоставляющий возможности более эффективного и тонкого контроля блокировки ресурсов. 
**ReentrantLock** – распространённая реализация Lock, которая предоставляет Lock с таким же базовым поведением и семантикой, 
как у synchronized, но расширенными возможностями, такими как опрос о блокировании (lock polling), 
ожидание блокирования заданной длительности и прерываемое ожидание блокировки. 
Кроме того, он предлагает гораздо более высокую эффективность функционирования в условиях жесткой состязательности.

Что понимается под блокировкой с повторным входом (reentrant)? Просто то, что есть подсчет сбора данных, связанный с блокировкой, 
и если поток, который удерживает блокировку, снова ее получает, данные отражают увеличение, 
и тогда для реального разблокирования нужно два раза снять блокировку. Это аналогично семантике synchronized; 
если поток входит в синхронный блок, защищенный монитором, который уже принадлежит потоку, потоку будет разрешено 
дальнейшее функционирование, и блокировка не будет снята, когда поток выйдет из второго (или последующего) блока synchronized, 
она будет снята только когда он выйдет из первого блока synchronized, в который он вошел под защитой монитора.

```java
Lock lock = new ReentrantLock();

lock.lock();
try { 
  // update object state
}
finally {
  lock.unlock(); 
}
```

Реализация ReentrantLock гораздо более масштабируема в условиях состязательности, чем реализация synchronized. 
Это значит, что когда много потоков соперничают за право получения блокировки, 
общая пропускная способность обычно лучше у ReentrantLock, чем у synchronized. 
JVM требуется меньше времени на установление очередности потоков и больше времени на непосредственно выполнение.
У ReentrantLock (как и у других реализаций Lock) блокировка должна обязательно сниматься в finally блоке 
(иначе, если бы защищенный код выбросил исключение, блокировка не была бы снята). 
Используя синхронизацию, JVM гарантирует, что блокировка автоматически снимаются.
Резюмируя можно сказать, что когда состязания за блокировку нет либо оно очень мало, то synchronized возможно будет быстрее. 
Если присутствует заметное состязание за доступ к ресурсу, то скорее всего ReentrantLock даст некое преимущество.

[к оглавлению](#Multithreading)

## 13 Приведите наиболее существенное отличие между CountDownLatch и Barrier

+ **CountDownLatch** (замок с обратным отсчетом) предоставляет возможность любому количеству потоков в блоке кода ожидать до тех пор, 
пока не завершится определенное количество операций, выполняющихся в других потоках, перед тем как они будут «отпущены», 
чтобы продолжить свою деятельность. 
В конструктор CountDownLatch(int count) обязательно передается количество операций, которое должно быть выполнено, 
чтобы замок «отпустил» заблокированные потоки.
Для ожидания по самоблокировке в потоке исполнения вызывается метод await(), общие формы которого приведены ниже.

```java
void await() throws InterruptedException
boolean await(long , TimeUnit _) throws InterruptedException
```

В первой форме ожидание длится до тех пор, пока отсчет, связанный с вызывающим объектом типа CountDownLatch, не достигнет нуля. 
А во второй форме ожидание длится только в течение определенного периода времени, определяе­мого параметром ожидание.

Метод await() возвращает ло­гическое значение false, если достигнут предел времени ожидания, или логиче­ское значение true, если обратный отсчет достигает нуля.

Чтобы известить о событии, следует вызвать метод countDown(). 
Всякий раз, когда вызывается метод countDown(), отсчет, связанный с вызывающим объектом, уменьшается на единицу.

```java
void countDown()
```

    Примером CountDownLatch из жизни может служить сбор экскурсионной группы: пока не наберется определенное количество человек, экскурсия не начнется.

+ **CyclicBarrier** реализует шаблон синхронизации «Барьер». Циклический барьер является точкой синхронизации, 
в которой указанное количество параллельных потоков встречается и блокируется. 
Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если барьер был инициализирован без него), 
и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». 
В конструкторы барьера CyclicBarrier(int parties) и CyclicBarrier(int parties, Runnable barrierAction) 
обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие, 
которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены».

CyclicBarrier является альтернативой метода join(), который «собирает» потоки только после того, как они выполнились.

CyclicBarrier похож на CountDownLatch, но главное различие между ними в том, 
что использовать «замок» можно лишь единожды - после того, как его счётчик достигнет нуля, 
а «барьер» можно использовать неоднократно, даже после того, как он «сломается».

[к оглавлению](#Multithreading)

## 14 Отличие Thread.start и Thread.run

Несмотря на то, что start() вызывает метод run() внутри себя, это не то же самое, что просто вызов run(). 
Если **run()** вызывается как обычный метод, то он **вызывается в том же потоке и никакой новый поток не запускается**, 
как это происходит, в случае, когда вы вызываете метод start().

[к оглавлению](#Multithreading)

## 15 Объясните ключевое слово volatile

**volatile** - этот модификатор вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной. 
Если переменная примитивного типа – этого будет достаточно для обеспечения потокобезопасности. 
Если же переменная является ссылкой на объект – синхронизировано будет исключительно значение этой ссылки. 
Все же данные, содержащиеся в объекте, синхронизированы не будут!

[к оглавлению](#Multithreading)

## 16 Расскажите про приоритеты потока

Приоритеты потоков используются планировщиком потоков для принятия решений о том, 
когда какому из потоков будет разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, 
чем низкоприоритетные. Практически объем времени процессора, 
который получает поток, часто зависит от нескольких факторов помимо его приоритета.

Чтобы установить приоритет потока, используется метод класса Thread: final void setPriority(int level). 
Значение level изменяется в пределах от Thread.MIN_PRIORITY = 1 до Thread.MAX_PRIORITY = 10. 
Приоритет по умолчанию - Thread.NORM_PRlORITY = 5.

Получить текущее значение приоритета потока можно вызвав метод: final int getPriority() у экземпляра класса Thread.

[к оглавлению](#Multithreading)

## 17 Что такое потоки демоны

Потоки-демоны работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы. 
Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается 
в обслуживании основных потоков приложения, то такой процесс может быть запущен как поток-демон с помощью метода 
setDaemon(boolean value), вызванного у потока до его запуска. Метод boolean isDaemon() позволяет определить, 
является ли указанный поток демоном или нет. Базовое свойство потоков-демонов заключается в возможности основного 
потока приложения завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода main(), 
не обращая внимания на то, что поток-демон еще работает.

+ Когда создается новый поток, он наследует статус демона своего родителя.
+ Когда все потоки, не являющиеся демонами, заканчивают работу, JVM останавливается, а все оставшиеся потоки демонов удаляются:
    + наконец блоки не выполняются,
    + стеки не разматываются - JVM просто выходит. 

По этой причине потоки демонов следует использовать с осторожностью, 
и их опасно использовать для задач, которые могут выполнять любые операции ввода-вывода.

[к оглавлению](#Multithreading)

## 18 Назовите все возможные состояния потока

Потоки могут находиться в одном из следующих состояний:

+ Новый (New). После создания экземпляра потока, он находится в состоянии Новый до тех пор, пока не вызван метод start(). 
В этом состоянии поток не считается живым.
+ Работоспособный (Runnable). Поток переходит в состояние Работоспособный, когда вызывается метод start(). 
Поток может перейти в это состояние также из состояния Работающий или из состояния Блокирован. 
Когда поток находится в этом состоянии, он считается живым.
+ Работающий (Running). Поток переходит из состояния Работоспособный в состояние Работающий, 
когда Планировщик потоков выбирает его как работающий в данный момент.
+ Живой, но не работоспособный (Alive, but not runnable). Поток может быть живым, но не работоспособным по нескольким причинам:
+ Ожидание (Waiting). Поток переходит в состояние Ожидания, вызывая метод wait(). Вызов notify() или notifyAll() может перевести поток из состояния Ожидания в состояние Работоспособный.
+ Сон (Sleeping). Метод sleep() переводит поток в состояние Сна на заданный промежуток времени в миллисекундах.
+ Блокировка (Blocked). Поток может перейти в это состояние, в ожидании ресурса, такого как ввод/вывод или из-за блокировки другого объекта. В этом случае поток переходит в состояние Работоспособный, когда ресурс становится доступен.
+ Мёртвый (Dead). Поток считается мёртвым, когда его метод run() полностью выполнен. Мёртвый поток не может перейти ни в какое другое состояние, даже если для него вызван метод start().

[к оглавлению](#Multithreading)

## 19 Что такое race condition

**Состояние гонки (race condition)** - ошибка проектирования многопоточной системы или приложения, 
при которой эта работа напрямую зависит от того, в каком порядке выполняются потоки. 
Состояние гонки возникает когда поток, который должен исполнится в начале, проиграл гонку и первым исполняется другой поток: 
поведение кода изменяется, из-за чего возникают недетерменированные ошибки.

Распространённые способы решения:

+ Использование локальной копии — копирование разделяемой переменной в локальную переменную потока. 
Этот способ работает только тогда, когда переменная одна и копирование производится атомарно (за одну машинную команду), 
использование volatile.
+ Синхронизация - операции над разделяемым ресурсом происходят в синхронизированном блоке (при использовании ключевого слова synchronized).
+ Комбинирование методов - вышеперечисленные способы можно комбинировать, копируя «опасные» переменные в синхронизированном блоке. 
С одной стороны, это снимает ограничение на атомарность, с другой — позволяет избавиться от слишком больших синхронизированных блоков.
Очевидных способов выявления и исправления состояний гонки не существует. 
Лучший способ избавиться от гонок — правильное проектирование многозадачной системы.

[к оглавлению](#Multithreading)

## 20 Что такое Thread Local переменная

**ThreadLocal** - класс, позволяющий имея одну переменную, иметь различное её значение для каждого из потоков.
У каждого потока - т.е. экземпляра класса Thread - есть ассоциированная с ним таблица ThreadLocal-переменных. 
Ключами таблицы являются cсылки на объекты класса ThreadLocal, 
а значениями - ссылки на объекты, «захваченные» ThreadLocal-переменными, 
т.е. ThreadLocal-переменные отличаются от обычных переменных тем, 
что у каждого потока свой собственный, индивидуально инициализируемый экземпляр переменной. 
Доступ к значению можно получить через методы get() или set().

Например, если мы объявим ThreadLocal-переменную: ThreadLocal<Object> locals = new ThreadLocal<Object>();. 
А затем, в потоке, сделаем locals.set(myObject), то ключом таблицы будет ссылка на объект locals, 
а значением - ссылка на объект myObject. При этом для другого потока существует возможность «положить» внутрь locals другое значение.

Следует обратить внимание, что ThreadLocal изолирует именно ссылки на объекты, а не сами объекты. 
Если изолированные внутри потоков ссылки ведут на один и тот же объект, то возможны коллизии.

Так же важно отметить, что т.к. ThreadLocal-переменные изолированы в потоках, 
то инициализация такой переменной должна происходить в том же потоке, в котором она будет использоваться. 
Ошибкой является инициализация такой переменной (вызов метода set()) в главном потоке приложения, 
потому как в данном случае значение, переданное в методе set(), будет «захвачено» для главного потока, 
и при вызове метода get() в целевом потоке будет возвращен null.

[к оглавлению](#Multithreading)

## 21 Что такое FutureTask

**FutureTask** представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. 
Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, 
методами для запроса состояния вычисления и извлечения результатов. 
Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено. 
Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. 
Так как FutureTask реализует Runnable, его можно передать в Executor на выполнение.

```java
        // создаем 2 future таска для 2х callable объектов
        FutureTask<String> futureTask1 = new FutureTask<String>(callable1);
        FutureTask<String> futureTask2 = new FutureTask<String>(callable2);
 
        // екзекьютор с размером пула в 2 потока
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        // стартуем
        executor.execute(futureTask1);
        executor.execute(futureTask2);
         
        // выполняем в бесконечном цикле, пока 
        // executor service не закончит выполнение всех future тасков
        while (true) {
            try {
                if(futureTask1.isDone() && futureTask2.isDone()){
                    System.out.println("Done");
                    // заканчиваем работу executor service
                    executor.shutdown();
                    return;
                }
                 
                if(!futureTask1.isDone()){
                // ждем, пока future task не закончит выполнение
                System.out.println("Результат выполнения FutureTask1 = " + futureTask1.get());
                }
                 
                System.out.println("Ждем, пока FutureTask2 не закончит свое выполнение");
                String s = futureTask2.get(200L, TimeUnit.MILLISECONDS);
                if(s !=null){
                    System.out.println("Результат выполнения FutureTask2 = " + s);
                }
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }catch(TimeoutException e){
                //оставим пустым
            }
```

[к оглавлению](#Multithreading)

## 22 Что такое Thread Pool

Создание потока является затратной по времени и ресурсам операцией. 
Количество потоков, которое может быть запущено в рамках одного процесса также ограниченно. 
Чтобы избежать этих проблем и в целом управлять множеством потоков более эффективно в Java был реализован механизм пула потоков (thread pool), 
который создаётся во время запуска приложения и в дальнейшем потоки для обработки запросов берутся и переиспользуются уже из него. 
Таким образом, появляется возможность не терять потоки, сбалансировать приложение по количеству потоков и частоте их создания.

Начиная с Java 1.5 Java API предоставляет фреймворк Executor, который позволяет создавать различные типы пула потоков:

+ Executor - упрощенный интерфейс пула, содержит один метод для передачи задачи на выполнение;
+ ExecutorService - расширенный интерфейс пула, с возможностью завершения всех потоков;
+ AbstractExecutorService - базовый класс пула, реализующий интерфейс ExecutorService;
+ Executors - фабрика объектов связанных с пулом потоков, в том числе позволяет создать основные типы пулов;
+ ThreadPoolExecutor - пул потоков с гибкой настройкой, может служить базовым классом для нестандартных пулов;
+ ForkJoinPool - пул для выполнения задач типа ForkJoinTask;
+ ... и другие.

Методы Executors для создания пулов:

+ newCachedThreadPool() - если есть свободный поток, то задача выполняется в нем, иначе добавляется новый поток в пул. 
Потоки не используемые больше минуты завершаются и удалются и кэша. Размер пула неограничен. 
Предназначен для выполнения множество небольших асинхронных задач;
+ newCachedThreadPool(ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;
+ newFixedThreadPool(int nThreads) - создает пул на указанное число потоков. 
Если новые задачи добавлены, когда все потоки активны, то они будут сохранены в очереди для выполнения позже. 
Если один из потоко завершился из-за ошибки, на его место будет запущен другой поток. 
Потоки живут до тех пор, пока пул не будет закрыт явно методом shutdown().
+ newFixedThreadPool(int nThreads, ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков; 
+ newSingleThreadScheduledExecutor() - однопотоковый пул с возможностью выполнять задачу через указанное время или выполнять периодически. 
Если поток был завершен из-за каких-либо ошибок, то для выполнения следующей задачи будет создан новый поток.
+ newSingleThreadScheduledExecutor(ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;
+ newScheduledThreadPool(int corePoolSize) - пул для выполнения задач через указанное время или переодически;
+ newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;
+ unconfigurableExecutorService(ExecutorService executor) - обертка на пул, запрещающая изменять его конфигурацию;

[к оглавлению](#Multithreading)

## 23 Что такое Semaphore

**Semaphore** – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон синхронизации Семафор. 
Доступ управляется с помощью счётчика: изначальное значение счётчика задаётся в конструкторе при создании синхронизатора, 
когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток его покидает, то увеличивается. 
Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока. 
Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле.

[к оглавлению](#Multithreading)

## 24 Чем отличается submit от execute у ExecutorServices

Оба метода являются способами подачи задачи в пул потоков, но между ними есть небольшая разница.
+ **execute**(Runnable command) определён в интерфейсе Executor и выполняет поданную задачу и ничего не возвращает.
+ **submit()** – перегруженный метод, определённый в интерфейсе ExecutorService. 
Способен принимать задачи типов Runnable и Callable и возвращать объект Future, 
который можно использовать для контроля и управления процессом выполнения, получения его результата.

[к оглавлению](#Multithreading)

## 25 Чем отличается shutdown от shutdownNow у ThreadPoolExecutor

+ **shutdown()** will just tell the executor service that it can't accept new tasks, 
but the already submitted tasks continue to run
+ **shutdownNow()** will do the same AND will try to cancel the already submitted tasks by interrupting the relevant threads. 
Note that if your tasks ignore the interruption, shutdownNow will behave exactly the same way as shutdown.

[к оглавлению](#Multithreading)

## 27 Как создать ThreadPool у ExecutorService только на 1 на 5 на неограниченное количество потоков

Например, если надо создать пул с 2мя потоками, то делается это так:
```java
ExecutorService service = Executors.newFixedThreadPool(2);
```

Если требуется использовать кэширующий пул потоков, который создает потоки по мере необходимости, 
но переиспользует неактивные потоки (и подчищает потоки, которые были неактивные некоторое время), то это задается следующим образом:
```java
ExecutorService service = Executors.newCachedThreadPool();
```

[к оглавлению](#Multithreading)

## 28 Что такое ReadWriteLock

**ReadWriteLock** – это интерфейс расширяющий базовый интерфейс Lock. 
Используется для улучшения производительности в многопоточном процессе и оперирует парой связанных блокировок (одна - для операций чтения, другая - для записи). 
Блокировка чтения может удерживаться одновременно несколькими читающими потоками, до тех пор пока не появится записывающий. 
Блокировка записи является эксклюзивной.

Существует реализующий интерфейс ReadWriteLock класс ReentrantReadWriteLock, 
который поддерживает до 65535 блокировок записи и до стольки же блокировок чтения.

```java
ReadWriteLock rwLock = new ReentrantReadWriteLock();
Lock rLock = rwLock.readLock();
Lock wLock = rwLock.writeLock();

wLock.lock();
try {
    // exclusive write
} finally {
    wLock.unlock();
}
        
rLock.lock();
try {
    // shared reading
} finally {
    rLock.unlock();
}
```

[к оглавлению](#Multithreading)

## 29 В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt и FutureTask.cancel

**FutureTask** представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. 
Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, 
методами для запроса состояния вычисления и извлечения результатов. 
Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, 
если вычисление ещё не завершено. 
Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. 
Так как FutureTask реализует Runnable, его можно передать в Executor на выполнение.

у Future есть метод Future.cancel(boolean), который должен отменить выполнение задачи. 
В недрах реализации FutureTask выполняется код:

```java
if (mayInterruptIfRunning) {
Thread r = runner;
if (r != null)
r.interrupt(); }
```

[к оглавлению](#Multithreading)

## 30 Расскажите про шаблон проектирования Producer Consumer

Шаблон заключается в разделении потоков по виду их деятельность на поставщиков и потребителей. 
Поставщики и потребители не общаются друг с другом напрямую, вместо этого передавая работу через общую очередь. 
Такой подход позволяет независимо разрабатывать поставщиков и потребителей, 
так как они не знают друг о друге, но знают только формат общения. 
Другое преимущество - возможность поставщиков и потребителей работать на разной скорости: 
медленный потребитель не будет тормозить быстрого поставщика.

[к оглавлению](#Multithreading)