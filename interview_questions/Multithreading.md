## Multithreading

+ [1. Чем отличается процесс от потока?](#1-Чем-отличается-процесс-от-потока)
+ [2. Каким образом можно создать поток?](#2-Каким-образом-можно-создать-поток)
+ [3. Как работают методы sleep, yield, wait, notify и notifyAll?](#3-Как-работают-методы-sleep-yield-wait-notify-и-notifyAll)
+ [4. Объясните следующие термины: монитор, мьютекс, критическая секция.](#4-Объясните-следующие-термины-монитор-мьютекс-критическая-секция)
+ [5. Как работает join?](#5-Как-работает-join)
+ [6. Что такое DeadLock? Приведите примеры.](#6-Что-такое-DeadLock-Приведите-примеры)
+ [7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.](#7-Назовите-различия-между-CollectionssynchronizedMapnew-HashMap-и-ConcurrentHashMap)
+ [8. Различия в интерфейсах Runnable и Callable.](#8-Различия-в-интерфейсах-Runnable-и-Callable)
+ [9. Различя между isInterrupted, interrupted.](#9-Различия-между-isInterrupted-interrupted)
+ [10. Что происходит при вызове Thread.interrupt()?](#10-Что-происходит-при-вызове-Threadinterrupt)
+ [11. Перечислите ВСЕ причины по которым может выскочить InterruptedException.](#11-Перечислите-ВСЕ-причины-по-которым-может-выскочить-InterruptedException)
+ [12. Назовите отличия synchronize{} и ReentrantLock.](#12-Назовите-отличия-synchronize-и-ReentrantLock)
+ [13. Приведите наиболее существенное отличие между CountDownLatch и Barrier.](#13-Приведите-наиболее-существенное-отличие-между-CountDownLatch-и-Barrier)
+ [14. Отличие Thread.start и Thread.run?](#14-Отличие-Threadstart-и-Threadrun)
+ [15. Объясните ключевое слово volatile.](#15-Объясните-ключевое-слово-volatile)
+ [16. Расскажите про приоритеты потока.](#16-Расскажите-про-приоритеты-потока)
+ [17. Что такое потоки-демоны?](#17-Что-такое-потоки-демоны)
+ [18. Назовите все возможные состояния потока.](#18-Назовите-все-возможные-состояния-потока)
+ [19. Что такое race condition?](#19-Что-такое-race-condition)
+ [20. Что такое Thread Local переменная?](#20-Что-такое-Thread-Local-переменная)
+ [21. Что такое FutureTask?](#21-Что-такое-FutureTask)
+ [22. Что такое Thread Pool?](#22-Что-такое-Thread-Pool)
+ [23. Что такое Semaphore?](#23-Что-такое-Semaphore)
+ [24. Чем отличается submit от execute у ExecutorServices?](#24-Чем-отличается-submit-от-execute-у-ExecutorServices)
+ [25. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?](#25-Чем-отличается-shutdown-от-shutdownNow-у-ThreadPoolExecutor)
+ [27. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.](#27-Как-создать-ThreadPool-у-ExecutorService-только-на-1-на-5-на-неограниченное-количество-потоков)
+ [28. Что такое ReadWriteLock?](#28-Что-такое-ReadWriteLock)
+ [29. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt и FutureTask.cancel.](#29-В-чём-отличие-Thread-от-FutureTask-В-чём-отличие-Threadinterrupt-и-FutureTaskcancel)
+ [30. Расскажите про шаблон проектирования Producer Consumer.](#30-Расскажите-про-шаблон-проектирования-Producer-Consumer)
+ [31. ConcurrentMap](#31-ConcurrentMap)
+ [32. Atomic Variables](#32-Atomic-Variables)
+ [33. Visibility Problem](#33-Visibility-Problem)
+ [34. ABA Problem](#34-ABA-Problem)
+ [35. Future vs CompletableFuture](#35-Future-vs-CompletableFuture)
+ [36. ForkJoinPool](#36-ForkJoinPool)

## 1 Чем отличается процесс от потока

+ **Процесс** - это Отдельно запущенное приложение и у него есть своя область памяти (минимум 1 поток).
+ **Поток** - это паралельные нити выполнения внутри одного процесса которые разделяют общую память.

[к оглавлению](#Multithreading)

## 2 Каким образом можно создать поток

+ Создать потомка класса Thread и переопределить его метод run();
+ Создать объект класса Thread, передав ему в конструкторе экземпляр класса, реализующего интерфейс Runnable. 
Эти интерфейс содержит метод run(), который будет выполняться в новом потоке. 
Поток закончит выполнение, когда завершится его метод run().
+ Вызвать метод submit() у экземпляра класса реализующего интерфейс ExecutorService, 
передав ему в качестве параметра экземпляр класса реализующего интерфейс Runnable или Callable (содержит метод call(), в котором описывается логика выполнения).

[к оглавлению](#Multithreading)

## 3 Как работают методы sleep yield wait notify и notifyAll

+ sleep - усыпляет поток, не освобождает lock объект
+ wait - усыпляет поток, освобождает lock объект
+ notify - будит последний стоящий в очереди поток
+ notifyAll - будит все стоящие в очереди объекты
+ yield - это попытка уступить очередь потокам, решает jvm.

[к оглавлению](#Multithreading)

## 4 Объясните следующие термины: монитор мьютекс критическая секция

**Монитор, мьютекс (mutex)** – это средство обеспечения контроля за доступом к ресурсу. 
У монитора может быть максимум один владелец в каждый текущий момент времени. 
Следовательно, если кто-то использует ресурс и захватил монитор для обеспечения единоличного доступа, то другой, 
желающий использовать тот же ресурс, должен подождать освобождения монитора, 
захватить его и только потом начать использовать ресурс.

Удобно представлять монитор как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. 
Если не 0 – ресурс занят. Можно встать в очередь и ждать его освобождения.

В Java у каждого экземпляра объекта есть монитор, который контролируется непосредственно виртуальной машиной. 
Используется он так: любой нестатический synchronized-метод при своем вызове прежде всего пытается захватить монитор того объекта, 
у которого он вызван (на который он может сослаться как на this). Если это удалось – метод исполняется. 
Если нет – поток останавливается и ждет, пока монитор будет отпущен.

Монитор — это дополнительная «надстройка» над мьютексом. По сути, монитор в Java выражен с помощью слова synchronized

[к оглавлению](#Multithreading)

## 5 Как работает join

Когда поток вызывает join() для другого потока, текущий работающий поток будет ждать, пока другой поток, 
к которому он присоединяется, не будет завершён:

```java
    void join()        
    void join(long millis) 
    void join(long millis, int nanos) 
```
Иначе основной поток продолжить выполнение параллельно

[к оглавлению](#Multithreading)

## 6 Что такое DeadLock Приведите примеры

Взаимная блокировка (deadlock) - явление при котором все потоки находятся в режиме ожидания. Происходит, когда достигаются состояния:

+ **Взаимная блокировка порядка синхронизации**
```java
public void transferMoney(Account fromAccount, Account toAccount, Amount amount) throws InsufficientFundsException {
	synchronized (fromAccount) {
		synchronized (toAccount) {
			if (fromAccount.getBalance().compareTo(amount) < 0)
				throw new InsufficientFundsException();
			else {
				fromAccount.debit(amount);
				toAccount.credit(amount);
			}
		}
	}
}
```
Данная блокировка вызвана тем, что синхронизация счетов может происходить в разном порядке. 
Соответственно, если ввести некоторый порядок на счетах (это некоторое правило, позволяющее сказать, что счет A меньше чем счет B), то проблема будет устранена.
+ **Взаимная блокировка между объектами.**
```java
class Plane {
	private Point location, destination;
	private final Dispatcher dispatcher;

	public Plane(Dispatcher dispatcher) {
		this.dispatcher = dispatcher;
	}
	public synchronized Point getLocation() {
		return location;
	}
	public synchronized void setLocation(Point location) {
		this.location = location;
		if (location.equals(destination))
		dispatcher.requestLanding(this);
	}
}

class Dispatcher {
	private final Set<Plane> planes;
	private final Set<Plane> planesPendingLanding;

	public Dispatcher() {
		planes = new HashSet<Plane>();
		planesPendingLanding = new HashSet<Plane>();
	}
	public synchronized void requestLanding(Plane plane) {
		planesPendingLanding.add(plane);
	}
	public synchronized Image getMap() {
		Image image = new Image();
		for (Plane plane : planes)
			image.drawMarker(plane.getLocation());
		return image;
	}
}
```

В результате, если самолет прибывает на место, в тот же момент, как кто-то решает получить карту может возникнуть взаимная блокировка. 
То есть, будут вызваны методы, getMap и setLocation, которые займут мониторы экземпляров Dispatcher и Plane соответственно. 
Затем метод getMap вызовет plane.getLocation (в частности для экземпляра Plane, который в данный момент занят), 
который будет ждать освобождения монитора для каждого из экземпляров Plane. 
В то же время в методе setLocation будет вызван dispatcher.requestLanding, при этом монитор экземпляра Dispatcher остается занят рисованием карты. 
Результат – взаимная блокировка.

+ **Ресурсная взаимная блокировка**. 
Безусловно, если код написан без каких-либо ошибок (примеры которых мы видели в предыдущих разделах), 
то взаимных блокировок в нем не будет. Но кто может поручиться, что его код написан без ошибок? 
Безусловно, тестирование помогает выявить значительную часть ошибок, но как мы уже видели ранее, 
ошибки в многопоточном коде нелегко диагностировать и даже после тестирования нельзя быть уверенным в отсутствии ситуаций взаимных блокировок. 
Можем ли мы как-то перестраховаться от блокировок? Ответ – да. Подобные техники применяются в движках баз данных, 
которым нередко необходимо восстанавливаться после взаимных блокировок (связанных с механизмом транзакций в БД).
                                     
Интерфейс Lock и его реализации доступные в пакете java.util.concurrent.locks позволяют попытаться занять монитор, 
связанный с экземпляром данного класса методом tryLock (возвращает true, если удалось занять монитор). 
Пусть у нас есть пара объектов реализующих интерфейс Lock и нам необходимо занять их мониторы так, чтоб избежать взаимной блокировки.

Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. Этого можно достичь, 
получая мониторы разделяемых ресурсов в определённом порядке и освобождая их в обратном порядке.

[к оглавлению](#Multithreading)

## 7 Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap

Оба являются синхронизированными версиями HashMap c различиями в функциональности и внутренней структуре. 
**ConcurrentHashMap** состоит из внутренних сегментов, которые могут рассматриваться как независимые HashMap’ы концептуально. 
Все эти сегменты могу быть заблокированы отдельными потоками выполняемыми одновременно. 
Таким образом несколько потоков могу одновременно получить/положить пары key-value из ConcurrentHashMap без блокирования/ожидания друг друга.
использует очень сложные методы для уменьшения необходимости синхронизации 
и обеспечения параллельного доступа для чтения несколькими потоками без синхронизации и, 
что более важно, предоставляет Iterator, который не требует синхронизации, 
и даже позволяет изменять Карту во время (хотя он **не гарантирует, будут ли возвращены элементы, вставленные во время итерации**).

**Из Collections.synchronizedMap()** мы получаем синхронизированную версию HashMap и доступ в блокировании образом. 
Это означает то что если несколько потоков пытаются получить доступ к synchronizedMap в одно и тоже время 
им будет позволено взять/положить пары key-value по одному синхронизированному образу.
они используют очень простую синхронизацию, а это означает, что только один поток может одновременно получить доступ к карте.
Это не большая проблема, когда у вас есть простые вставки и поиск (если вы не делаете это очень интенсивно), 
но **становится большой проблемой, когда вам нужно перебирать всю карту**, 
что может занять много времени для большой Карты. В то время как один поток делает это, все остальные должны ждать, 
хотят ли они вставлять или искать что-либо.


[к оглавлению](#Multithreading)

## 8 Различия в интерфейсах Runnable и Callable

+ Интерфейс Runnable появиля в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent;
+ Классы, реализующие интерфейс Runnable для выполнения задачи должны реализовывать метод run(). 
Классы, реализующие интерфейс Callable - метод call();
+ Метод Runnable.run() не возвращает никакого значения, Callable.call() возвращает объект Future, 
который может содержать результат вычислений;
+ Метод run() не может выбрасывать проверяемые исключения, в то время как метод call() может.

[к оглавлению](#Multithreading)

## 9 Различия между isInterrupted interrupted

Механизм прерывания работы потока в Java реализован с использованием внутреннего флага, известного как статус прерывания. 
Прерывание потока вызовом Thread.interrupt() устанавливает этот флаг.
 
Методы Thread.interrupted() и isInterrupted() позволяют проверить, является ли поток прерванным.
+ Когда прерванный поток проверяет статус прерывания, вызывая статический метод Thread.interrupted(), 
статус прерывания сбрасывается. Фактически, это еще и ограничивает возможность снять флаг прерывания у других тредов (нельзя "украсть" прерывание другого треда).

+ Нестатический метод isInterrupted() используется одним потоком для проверки статуса прерывания у другого потока, 
не изменяя флаг прерывания.

[к оглавлению](#Multithreading)

## 10 Что происходит при вызове Thread.interrupt()

Устанавливает флаг прерывания.

[к оглавлению](#Multithreading)

## 11 Перечислите ВСЕ причины по которым может выскочить InterruptedException

+ Поток прерван во время ожидания на мониторе
+ Поток прерван во время засыпания
+ Поток прерван во время захвата ReentrantLock через lockInterruptibly
+ Поток прерван во время ожидания в CountDownLatch через await
+ Поток прерван во время ожидания в CyclicBarrier через await
+ Поток прерван во время ожидания в Condition через await
+ Поток прерван во время захвата попытки в Semaphore через acquireUninterruptibly
+ Поток прерван во время получения значения в Future через get
+ Поток прерван во время обмена значенимя в Exchanger через exchange
+ Поток прерван во время блокирующих операций с BlockingQueue
+ Поток прерван во время работы с I/O через InterruptableChannel

В общем, почти любой блокирующий метод выбрасывает это исключение.

[к оглавлению](#Multithreading)

## 12 Назовите отличия synchronize{} и ReentrantLock

В Java 5 появился интерфейс Lock предоставляющий возможности более эффективного и тонкого контроля блокировки ресурсов. 
**ReentrantLock** – распространённая реализация Lock, которая предоставляет Lock с таким же базовым поведением и семантикой, 
как у synchronized, но расширенными возможностями, такими как опрос о блокировании (lock polling), 
ожидание блокирования заданной длительности и прерываемое ожидание блокировки. 
Кроме того, он предлагает гораздо более высокую эффективность функционирования в условиях жесткой состязательности.

Что понимается под блокировкой с повторным входом (reentrant)? Просто то, что есть подсчет сбора данных, связанный с блокировкой, 
и если поток, который удерживает блокировку, снова ее получает, данные отражают увеличение, 
и тогда для реального разблокирования нужно два раза снять блокировку. Это аналогично семантике synchronized; 
если поток входит в синхронный блок, защищенный монитором, который уже принадлежит потоку, потоку будет разрешено 
дальнейшее функционирование, и блокировка не будет снята, когда поток выйдет из второго (или последующего) блока synchronized, 
она будет снята только когда он выйдет из первого блока synchronized, в который он вошел под защитой монитора.

```java
Lock lock = new ReentrantLock();

lock.lock();
try { 
  // update object state
}
finally {
  lock.unlock(); 
}
```

Реализация ReentrantLock гораздо более масштабируема в условиях состязательности, чем реализация synchronized. 
Это значит, что когда много потоков соперничают за право получения блокировки, 
общая пропускная способность обычно лучше у ReentrantLock, чем у synchronized. 
JVM требуется меньше времени на установление очередности потоков и больше времени на непосредственно выполнение.
У ReentrantLock (как и у других реализаций Lock) блокировка должна обязательно сниматься в finally блоке 
(иначе, если бы защищенный код выбросил исключение, блокировка не была бы снята). 
Используя синхронизацию, JVM гарантирует, что блокировка автоматически снимаются.
Резюмируя можно сказать, что когда состязания за блокировку нет либо оно очень мало, то synchronized возможно будет быстрее. 
Если присутствует заметное состязание за доступ к ресурсу, то скорее всего ReentrantLock даст некое преимущество.

[к оглавлению](#Multithreading)

## 13 Приведите наиболее существенное отличие между CountDownLatch и Barrier

+ **CountDownLatch** (замок с обратным отсчетом) предоставляет возможность любому количеству потоков в блоке кода ожидать до тех пор, 
пока не завершится определенное количество операций, выполняющихся в других потоках, перед тем как они будут «отпущены», 
чтобы продолжить свою деятельность. 
В конструктор CountDownLatch(int count) обязательно передается количество операций, которое должно быть выполнено, 
чтобы замок «отпустил» заблокированные потоки.
Для ожидания по самоблокировке в потоке исполнения вызывается метод await(), общие формы которого приведены ниже.

```java
void await() throws InterruptedException
boolean await(long , TimeUnit _) throws InterruptedException
```

В первой форме ожидание длится до тех пор, пока отсчет, связанный с вызывающим объектом типа CountDownLatch, не достигнет нуля. 
А во второй форме ожидание длится только в течение определенного периода времени, определяе­мого параметром ожидание.

Метод await() возвращает ло­гическое значение false, если достигнут предел времени ожидания, или логиче­ское значение true, если обратный отсчет достигает нуля.

Чтобы известить о событии, следует вызвать метод countDown(). 
Всякий раз, когда вызывается метод countDown(), отсчет, связанный с вызывающим объектом, уменьшается на единицу.

```java
void countDown()
```

    Примером CountDownLatch из жизни может служить сбор экскурсионной группы: пока не наберется определенное количество человек, экскурсия не начнется.

+ **CyclicBarrier** реализует шаблон синхронизации «Барьер». Циклический барьер является точкой синхронизации, 
в которой указанное количество параллельных потоков встречается и блокируется. 
Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если барьер был инициализирован без него), 
и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». 
В конструкторы барьера CyclicBarrier(int parties) и CyclicBarrier(int parties, Runnable barrierAction) 
обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие, 
которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены».

CyclicBarrier является альтернативой метода join(), который «собирает» потоки только после того, как они выполнились.

CyclicBarrier похож на CountDownLatch, но главное различие между ними в том, 
что использовать «замок» можно лишь единожды - после того, как его счётчик достигнет нуля, 
а «барьер» можно использовать неоднократно, даже после того, как он «сломается».

[к оглавлению](#Multithreading)

## 14 Отличие Thread.start и Thread.run

Несмотря на то, что start() вызывает метод run() внутри себя, это не то же самое, что просто вызов run(). 
Если **run()** вызывается как обычный метод, то он **вызывается в том же потоке и никакой новый поток не запускается**, 
как это происходит, в случае, когда вы вызываете метод start().

[к оглавлению](#Multithreading)

## 15 Объясните ключевое слово volatile

**volatile** - этот модификатор вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной. 
Если переменная примитивного типа – этого будет достаточно для обеспечения потокобезопасности. 
Если же переменная является ссылкой на объект – синхронизировано будет исключительно значение этой ссылки. 
Все же данные, содержащиеся в объекте, синхронизированы не будут!

[к оглавлению](#Multithreading)

## 16 Расскажите про приоритеты потока

Приоритеты потоков используются планировщиком потоков для принятия решений о том, 
когда какому из потоков будет разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, 
чем низкоприоритетные. Практически объем времени процессора, 
который получает поток, часто зависит от нескольких факторов помимо его приоритета.

Чтобы установить приоритет потока, используется метод класса Thread: final void setPriority(int level). 
Значение level изменяется в пределах от Thread.MIN_PRIORITY = 1 до Thread.MAX_PRIORITY = 10. 
Приоритет по умолчанию - Thread.NORM_PRlORITY = 5.

Получить текущее значение приоритета потока можно вызвав метод: final int getPriority() у экземпляра класса Thread.

[к оглавлению](#Multithreading)

## 17 Что такое потоки демоны

Потоки-демоны работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы. 
Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается 
в обслуживании основных потоков приложения, то такой процесс может быть запущен как поток-демон с помощью метода 
setDaemon(boolean value), вызванного у потока до его запуска. Метод boolean isDaemon() позволяет определить, 
является ли указанный поток демоном или нет. Базовое свойство потоков-демонов заключается в возможности основного 
потока приложения завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода main(), 
не обращая внимания на то, что поток-демон еще работает.

+ Когда создается новый поток, он наследует статус демона своего родителя.
+ Когда все потоки, не являющиеся демонами, заканчивают работу, JVM останавливается, а все оставшиеся потоки демонов удаляются:
    + наконец блоки не выполняются,
    + стеки не разматываются - JVM просто выходит. 

По этой причине потоки демонов следует использовать с осторожностью, 
и их опасно использовать для задач, которые могут выполнять любые операции ввода-вывода.

[к оглавлению](#Multithreading)

## 18 Назовите все возможные состояния потока

Потоки могут находиться в одном из следующих состояний:

+ Новый (New). После создания экземпляра потока, он находится в состоянии Новый до тех пор, пока не вызван метод start(). 
В этом состоянии поток не считается живым.
+ Работоспособный (Runnable). Поток переходит в состояние Работоспособный, когда вызывается метод start(). 
Поток может перейти в это состояние также из состояния Работающий или из состояния Блокирован. 
Когда поток находится в этом состоянии, он считается живым.
+ Работающий (Running). Поток переходит из состояния Работоспособный в состояние Работающий, 
когда Планировщик потоков выбирает его как работающий в данный момент.
+ Живой, но не работоспособный (Alive, but not runnable). Поток может быть живым, но не работоспособным по нескольким причинам:
+ Ожидание (Waiting). Поток переходит в состояние Ожидания, вызывая метод wait(). Вызов notify() или notifyAll() может перевести поток из состояния Ожидания в состояние Работоспособный.
+ Сон (Sleeping). Метод sleep() переводит поток в состояние Сна на заданный промежуток времени в миллисекундах.
+ Блокировка (Blocked). Поток может перейти в это состояние, в ожидании ресурса, такого как ввод/вывод или из-за блокировки другого объекта. В этом случае поток переходит в состояние Работоспособный, когда ресурс становится доступен.
+ Мёртвый (Dead). Поток считается мёртвым, когда его метод run() полностью выполнен. Мёртвый поток не может перейти ни в какое другое состояние, даже если для него вызван метод start().

[к оглавлению](#Multithreading)

## 19 Что такое race condition

**Состояние гонки (race condition)** - ошибка проектирования многопоточной системы или приложения, 
при которой эта работа напрямую зависит от того, в каком порядке выполняются потоки. 
Состояние гонки возникает когда поток, который должен исполнится в начале, проиграл гонку и первым исполняется другой поток: 
поведение кода изменяется, из-за чего возникают недетерменированные ошибки.

Распространённые способы решения:

+ Использование локальной копии — копирование разделяемой переменной в локальную переменную потока. 
Этот способ работает только тогда, когда переменная одна и копирование производится атомарно (за одну машинную команду), 
использование volatile.
+ Синхронизация - операции над разделяемым ресурсом происходят в синхронизированном блоке (при использовании ключевого слова synchronized).
+ Комбинирование методов - вышеперечисленные способы можно комбинировать, копируя «опасные» переменные в синхронизированном блоке. 
С одной стороны, это снимает ограничение на атомарность, с другой — позволяет избавиться от слишком больших синхронизированных блоков.
Очевидных способов выявления и исправления состояний гонки не существует. 
Лучший способ избавиться от гонок — правильное проектирование многозадачной системы.

[к оглавлению](#Multithreading)

## 20 Что такое Thread Local переменная

**ThreadLocal** - класс, позволяющий имея одну переменную, иметь различное её значение для каждого из потоков.
У каждого потока - т.е. экземпляра класса Thread - есть ассоциированная с ним таблица ThreadLocal-переменных. 
Ключами таблицы являются cсылки на объекты класса ThreadLocal, 
а значениями - ссылки на объекты, «захваченные» ThreadLocal-переменными, 
т.е. ThreadLocal-переменные отличаются от обычных переменных тем, 
что у каждого потока свой собственный, индивидуально инициализируемый экземпляр переменной. 
Доступ к значению можно получить через методы get() или set().

Например, если мы объявим ThreadLocal-переменную: ThreadLocal<Object> locals = new ThreadLocal<Object>();. 
А затем, в потоке, сделаем locals.set(myObject), то ключом таблицы будет ссылка на объект locals, 
а значением - ссылка на объект myObject. При этом для другого потока существует возможность «положить» внутрь locals другое значение.

Следует обратить внимание, что ThreadLocal изолирует именно ссылки на объекты, а не сами объекты. 
Если изолированные внутри потоков ссылки ведут на один и тот же объект, то возможны коллизии.

Так же важно отметить, что т.к. ThreadLocal-переменные изолированы в потоках, 
то инициализация такой переменной должна происходить в том же потоке, в котором она будет использоваться. 
Ошибкой является инициализация такой переменной (вызов метода set()) в главном потоке приложения, 
потому как в данном случае значение, переданное в методе set(), будет «захвачено» для главного потока, 
и при вызове метода get() в целевом потоке будет возвращен null.

[к оглавлению](#Multithreading)

## 21 Что такое FutureTask

**FutureTask** представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. 
Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, 
методами для запроса состояния вычисления и извлечения результатов. 
Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено. 
Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. 
Так как FutureTask реализует Runnable, его можно передать в Executor на выполнение.

```java
        // создаем 2 future таска для 2х callable объектов
        FutureTask<String> futureTask1 = new FutureTask<String>(callable1);
        FutureTask<String> futureTask2 = new FutureTask<String>(callable2);
 
        // екзекьютор с размером пула в 2 потока
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        // стартуем
        executor.execute(futureTask1);
        executor.execute(futureTask2);
         
        // выполняем в бесконечном цикле, пока 
        // executor service не закончит выполнение всех future тасков
        while (true) {
            try {
                if(futureTask1.isDone() && futureTask2.isDone()){
                    System.out.println("Done");
                    // заканчиваем работу executor service
                    executor.shutdown();
                    return;
                }
                 
                if(!futureTask1.isDone()){
                // ждем, пока future task не закончит выполнение
                System.out.println("Результат выполнения FutureTask1 = " + futureTask1.get());
                }
                 
                System.out.println("Ждем, пока FutureTask2 не закончит свое выполнение");
                String s = futureTask2.get(200L, TimeUnit.MILLISECONDS);
                if(s !=null){
                    System.out.println("Результат выполнения FutureTask2 = " + s);
                }
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }catch(TimeoutException e){
                //оставим пустым
            }
```

[к оглавлению](#Multithreading)

## 22 Что такое Thread Pool

Создание потока является затратной по времени и ресурсам операцией. 
Количество потоков, которое может быть запущено в рамках одного процесса также ограниченно. 
Чтобы избежать этих проблем и в целом управлять множеством потоков более эффективно в Java был реализован механизм пула потоков (thread pool), 
который создаётся во время запуска приложения и в дальнейшем потоки для обработки запросов берутся и переиспользуются уже из него. 
Таким образом, появляется возможность не терять потоки, сбалансировать приложение по количеству потоков и частоте их создания.

Начиная с Java 1.5 Java API предоставляет фреймворк Executor, который позволяет создавать различные типы пула потоков:

+ Executor - упрощенный интерфейс пула, содержит один метод для передачи задачи на выполнение;
+ ExecutorService - расширенный интерфейс пула, с возможностью завершения всех потоков;
+ AbstractExecutorService - базовый класс пула, реализующий интерфейс ExecutorService;
+ Executors - фабрика объектов связанных с пулом потоков, в том числе позволяет создать основные типы пулов;
+ ThreadPoolExecutor - пул потоков с гибкой настройкой, может служить базовым классом для нестандартных пулов;
+ ForkJoinPool - пул для выполнения задач типа ForkJoinTask;
+ ... и другие.

Методы Executors для создания пулов:

+ newCachedThreadPool() - если есть свободный поток, то задача выполняется в нем, иначе добавляется новый поток в пул. 
Потоки не используемые больше минуты завершаются и удалются и кэша. Размер пула неограничен. 
Предназначен для выполнения множество небольших асинхронных задач;
+ newCachedThreadPool(ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;
+ newFixedThreadPool(int nThreads) - создает пул на указанное число потоков. 
Если новые задачи добавлены, когда все потоки активны, то они будут сохранены в очереди для выполнения позже. 
Если один из потоко завершился из-за ошибки, на его место будет запущен другой поток. 
Потоки живут до тех пор, пока пул не будет закрыт явно методом shutdown().
+ newFixedThreadPool(int nThreads, ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков; 
+ newSingleThreadScheduledExecutor() - однопотоковый пул с возможностью выполнять задачу через указанное время или выполнять периодически. 
Если поток был завершен из-за каких-либо ошибок, то для выполнения следующей задачи будет создан новый поток.
+ newSingleThreadScheduledExecutor(ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;
+ newScheduledThreadPool(int corePoolSize) - пул для выполнения задач через указанное время или переодически;
+ newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;
+ unconfigurableExecutorService(ExecutorService executor) - обертка на пул, запрещающая изменять его конфигурацию;

[к оглавлению](#Multithreading)

## 23 Что такое Semaphore

**Semaphore** – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон синхронизации Семафор. 
Доступ управляется с помощью счётчика: изначальное значение счётчика задаётся в конструкторе при создании синхронизатора, 
когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток его покидает, то увеличивается. 
Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока. 
Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле.

[к оглавлению](#Multithreading)

## 24 Чем отличается submit от execute у ExecutorServices

Оба метода являются способами подачи задачи в пул потоков, но между ними есть небольшая разница.
+ **execute**(Runnable command) определён в интерфейсе Executor и выполняет поданную задачу и ничего не возвращает.
+ **submit()** – перегруженный метод, определённый в интерфейсе ExecutorService. 
Способен принимать задачи типов Runnable и Callable и возвращать объект Future, 
который можно использовать для контроля и управления процессом выполнения, получения его результата.

[к оглавлению](#Multithreading)

## 25 Чем отличается shutdown от shutdownNow у ThreadPoolExecutor

+ **shutdown()** will just tell the executor service that it can't accept new tasks, 
but the already submitted tasks continue to run
+ **shutdownNow()** will do the same AND will try to cancel the already submitted tasks by interrupting the relevant threads. 
Note that if your tasks ignore the interruption, shutdownNow will behave exactly the same way as shutdown.

[к оглавлению](#Multithreading)

## 27 Как создать ThreadPool у ExecutorService только на 1 на 5 на неограниченное количество потоков

Например, если надо создать пул с 2мя потоками, то делается это так:
```java
ExecutorService service = Executors.newFixedThreadPool(2);
```

Если требуется использовать кэширующий пул потоков, который создает потоки по мере необходимости, 
но переиспользует неактивные потоки (и подчищает потоки, которые были неактивные некоторое время), то это задается следующим образом:
```java
ExecutorService service = Executors.newCachedThreadPool();
```

[к оглавлению](#Multithreading)

## 28 Что такое ReadWriteLock

**ReadWriteLock** – это интерфейс расширяющий базовый интерфейс Lock. 
Используется для улучшения производительности в многопоточном процессе и оперирует парой связанных блокировок (одна - для операций чтения, другая - для записи). 
Блокировка чтения может удерживаться одновременно несколькими читающими потоками, до тех пор пока не появится записывающий. 
Блокировка записи является эксклюзивной.

Существует реализующий интерфейс ReadWriteLock класс ReentrantReadWriteLock, 
который поддерживает до 65535 блокировок записи и до стольки же блокировок чтения.

```java
ReadWriteLock rwLock = new ReentrantReadWriteLock();
Lock rLock = rwLock.readLock();
Lock wLock = rwLock.writeLock();

wLock.lock();
try {
    // exclusive write
} finally {
    wLock.unlock();
}
        
rLock.lock();
try {
    // shared reading
} finally {
    rLock.unlock();
}
```

[к оглавлению](#Multithreading)

## 29 В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt и FutureTask.cancel

**FutureTask** представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. 
Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, 
методами для запроса состояния вычисления и извлечения результатов. 
Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, 
если вычисление ещё не завершено. 
Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. 
Так как FutureTask реализует Runnable, его можно передать в Executor на выполнение.

у Future есть метод Future.cancel(boolean), который должен отменить выполнение задачи. 
В недрах реализации FutureTask выполняется код:

```java
if (mayInterruptIfRunning) {
Thread r = runner;
if (r != null)
r.interrupt(); }
```

[к оглавлению](#Multithreading)

## 30 Расскажите про шаблон проектирования Producer Consumer

Шаблон заключается в разделении потоков по виду их деятельность на поставщиков и потребителей. 
Поставщики и потребители не общаются друг с другом напрямую, вместо этого передавая работу через общую очередь. 
Такой подход позволяет независимо разрабатывать поставщиков и потребителей, 
так как они не знают друг о друге, но знают только формат общения. 
Другое преимущество - возможность поставщиков и потребителей работать на разной скорости: 
медленный потребитель не будет тормозить быстрого поставщика.

[к оглавлению](#Multithreading)

## 31 ConcurrentMap
disabling the null key/value support

mainly uses CAS operations during updating. Each bucket can be independently locked by locking the very first node in the bucket. Read operations do not block, and update contentions are minimized. `concurrencyLevel` argument to control the number of estimated threads to use:
```java
public ConcurrentHashMap(
 int initialCapacity, float loadFactor, int concurrencyLevel)
```
[к оглавлению](#Multithreading)

## 32 Atomic Variables

Atomic classes ensure that, the increment will be an atomic operation.
These algorithms exploit low-level atomic machine instructions such as compare-and-swap (CAS), to ensure data integrity.

A typical CAS operation works on three operands:

+ The memory location on which to operate (M)
+ The existing expected value (A) of the variable
+ The new value (B) which needs to be set

The CAS operation updates atomically the value in M to B, but only if the existing value in M matches A, otherwise no action is taken.
When multiple threads attempt to update the same value through CAS, one of them wins and updates the value. However, unlike in the case of locks, no other thread gets suspended; instead, they’re simply informed that they did not manage to update the value. The threads can then proceed to do further work and context switches are completely avoided.

[к оглавлению](#Multithreading)

## 33 Visibility Problem
A visibility problem is one of the issues when working in a multithreaded application. The visibility problem is tightly connected to the Java memory model.

In multithreaded applications, each thread has its cached version of shared resources and updates the values in or from the main memory based on events or a schedule.

The thread cache and main memory values might differ. Therefore, even if one thread updates the values in the main memory, these changes are not instantly visible to other threads. This is called a visibility problem.

The `volatile` keyword helps us to resolve this issue by bypassing caching in a local thread. Thus, volatile variables are visible to all the threads, and all these threads will see the same value. Hence, when one thread updates the value, all the threads will see the new value. 

[к оглавлению](#Multithreading)

## 34 ABA Problem
Say, for example, that one activity reads some shared memory (A), in preparation for updating it. Then, another activity temporarily modifies that shared memory (B) and then restores it (A). Following that, once the first activity performs Compare and Swap, it will appear as if no change has been made, invalidating the integrity of the check.

While in many scenarios this doesn’t cause a problem, at times, A is not as equal to A as we might think.

We might encounter the ABA problem using reference types with the purpose of reusing them. In this case, at the end of the ABA scenario, we get the matching reference back, so the CAS operation succeeds, however, the reference might point to a different object than it did originally. This can lead to ambiguity.

### Solutions
+ **Immutability**: the usage of immutable objects solves this problem, as we don’t reuse objects across the application. Whenever something changes, a new object is created, so the CAS will fail for sure.
+ **Double Compare and Swap**
The idea behind the double compare and swap method is to keep track of one more variable, which is the version number, then use that in the comparison as well. In this case, the CAS operation will fail if we have the old version number, which is only possible when another thread modified our variable in the meantime.

[к оглавлению](#Multithreading)

## 35 Future vs CompletableFuture
### Future
Future is a placeholder for a result that will be produced by an asynchronous process and may not yet be available.
We can either cancel a task or get the result from a completed task and also check if a task has been canceled or completed.
The method that returns the actual result from the calculation is `Future.get()`. We can see that this method blocks the execution until the task is complete. However, this won’t be an issue in our example because we’ll check if the task is complete by calling `isDone()`.
```java
class ObjectCallable implements Callable<TestObject> {
    @Override
    TestObject call() {
        return new TestObject();
    }
}

Future<TestObject> future = exec.submit(new ObjectCallable());
    TestObject retrievedObject = future.get();

Future<Integer> future = new SquareCalculator().calculate(10);

while(!future.isDone()) {
    System.out.println("Calculating...");
    Thread.sleep(300);
}

Integer result = future.get();

Integer result = future.get(500, TimeUnit.MILLISECONDS);

boolean canceled = future.cancel(true);
```
### CompletableFuture
CompletableFuture is an implementation of the Future interface that was released with Java 8. It extends the basic functionality of Future to let us have a lot more control over the results of our asynchronous operations. One of the biggest pieces of added functionality is the option to chain function calls onto the result of the initial task.

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Hello");
assertEquals("Hello", future.get());

ExecutorService exec = Executors.newSingleThreadExecutor();
    ObjectHydrator objectHydrator = new ObjectHydrator();
    CompletableFuture<TestObject> future = CompletableFuture.supplyAsync(new ObjectSupplier(), exec)
      .thenApply(objectHydrator::hydrateTestObject);
TestObject retrievedObject = future.get();
```

When we need to execute multiple Futures in parallel, we usually want to wait for all of them to execute and then process their combined results.

The CompletableFuture.allOf static method allows to wait for the completion of all of the Futures provided as a var-arg:
```java
CompletableFuture<String> future1  
  = CompletableFuture.supplyAsync(() -> "Hello");
CompletableFuture<String> future2  
  = CompletableFuture.supplyAsync(() -> "Beautiful");
CompletableFuture<String> future3  
  = CompletableFuture.supplyAsync(() -> "World");

CompletableFuture<Void> combinedFuture 
  = CompletableFuture.allOf(future1, future2, future3);

// ...

combinedFuture.get();

assertTrue(future1.isDone());
assertTrue(future2.isDone());
assertTrue(future3.isDone());
```

Fortunately, CompletableFuture.join() method and Java 8 Streams API makes it simple
```java
String combined = Stream.of(future1, future2, future3)
  .map(CompletableFuture::join)
  .collect(Collectors.joining(" "));

assertEquals("Hello Beautiful World", combined);
```

For error handling in a chain of asynchronous computation steps, we have to adapt the throw/catch idiom in a similar fashion.

Instead of catching an exception in a syntactic block, the CompletableFuture class allows us to handle it in a special handle method. This method receives two parameters: a result of a computation (if it finished successfully) and the exception thrown (if some computation step did not complete normally).

```java
String name = null;

// ...

CompletableFuture<String> completableFuture  
  =  CompletableFuture.supplyAsync(() -> {
      if (name == null) {
          throw new RuntimeException("Computation error!");
      }
      return "Hello, " + name;
  }).handle((s, t) -> s != null ? s : "Hello, Stranger!");

assertEquals("Hello, Stranger!", completableFuture.get());
```
Most methods of the fluent API in the CompletableFuture class have two additional variants with the Async postfix. These methods are usually intended for running a corresponding execution step in another thread.


[к оглавлению](#Multithreading)

## 36 ForkJoinPool
The ForkJoinPool is the heart of the framework. It is an implementation of the ExecutorService that manages worker threads and provides us with tools to get information about the thread pool state and performance.

ForkJoinPool doesn’t create a separate thread for every single subtask. Instead, each thread in the pool has its own double-ended queue (or deque, pronounced “deck”) that stores tasks.

By default, a worker thread gets tasks from the head of its own deque. When it is empty, the thread takes a task from the tail of the deque of another busy thread or from the global entry queue since this is where the biggest pieces of work are likely to be located.

```java
public static ForkJoinPool forkJoinPool = new ForkJoinPool(2);
```

[к оглавлению](#Multithreading)
