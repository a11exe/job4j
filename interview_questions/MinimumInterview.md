# Вопросы для собеседования минимум

+ [1. Что такое java, характеристики языка](#1-Что-такое-java-характеристики-языка)
+ [2. Что значит высокоуровневый язык программирования](#2-Что-значит-высокоуровневый-язык-программирования)
+ [3. Какие бывают языки программирования](#3-Какие-бывают-языки-программирования)
+ [4. Принципы ООП, как реализована инкапсуляция в Java, полиморфизм](#4-Принципы-ООП-как-реализована-инкапсуляция-в-Java-полиморфизм)
+ [5. Модификаторы доступа](#5-Модификаторы-доступа)
+ [6. Принципы SOLID](#6-Принципы-SOLID)
+ [7. Опишите примитивные типы java](#7-Опишите-примитивные-типы-java)
+ [8. Последовательность инициализации блоков класса и его родителя](#8-Последовательность-инициализации-блоков-класса-и-его-родителя)
+ [9. Классы внутренние, вложенные, абстрактные](#9-Классы-внутренние-вложенные-абстрактные)
+ [10. Замыкания](#10-Замыкания)
+ [11. Методы класса Object](#11-Методы-класса-Object)
+ [12. Ключевое слово volatile? Понятие атомарной операции и как это связано с volatile?](#12-Ключевое-слово-volatile-Понятие-атомарной-операции-и-как-это-связано-с-volatile)
+ [13. Финализация объектов в Java](#13-Финализация-объектов-в-Java)
+ [14. Иерархия коллекций](#14-Иерархия-коллекций)
+ [15. Отличие Set от List, приведите примеры реализаций](#15-Отличие-Set-от-List-приведите-примеры-реализаций)
+ [16. Когда имеет смысл использовать LinkedList вместо ArrayList?](#16-Когда-имеет-смысл-использовать-LinkedList-вместо-ArrayList)
+ [17. Устройство HashMap](#17-Устройство-HashMap)
+ [18. Итераторы. Можно ли удалить элемент из коллекции в итерации цикла по коллекции?](#18-Итераторы-Можно-ли-удалить-элемент-из-коллекции-в-итерации-цикла-по-коллекции)
+ [19. Что такое fail-fast и fail-safe?](#19-Что-такое-fail-fast-и-fail-safe)
+ [20. Механизм сериализации в Java, его внутреннее устройство](#20-Механизм-сериализации-в-Java-его-внутреннее-устройство)
+ [21. Клонирование в Java](#21-Клонирование-в-Java)
+ [22. StringBuffer vs StringBuilder](#22-StringBuffer-vs-StringBuilder)
+ [23. Методы обработки XML документов.](#23-Методы-обработки-XML-документов)
+ [24. Особенности Java 8](#24-Особенности-Java-8)
+ [25. Зачем нужны лямбды?](#25-Зачем-нужны-лямбды)
+ [26. Зачем нужны исключения?](#26-Зачем-нужны-исключения)
+ [27. Иерархия исключений. Отличия checked от unchecked исключений. Назвать некоторые checked и unchecked исключения](#27-Иерархия-исключений-Отличия-checked-от-unchecked-исключений-Назвать-некоторые-checked-и-unchecked-исключения)
+ [28. Как определить свою аннотацию](#28-Как-определить-свою-аннотацию)
+ [29. Зачем нужны immutable объекты](#29-Зачем-нужны-immutable-объекты)
+ [30. Назовите паттерны проектирования, которые вы использовали](#30-Назовите-паттерны-проектирования-которые-вы-использовали)
+ [31. Scope'ы бинов в Spring'e](#31-Scope'ы-бинов-в-Spring'e)
+ [32. Какие книги читали по Java?](#32-Какие-книги-читали-по-Java)
+ [33. Как работает сборщик мусора в Java? Можно ли вызвать сборку мусора.](#33-Как-работает-сборщик-мусора-в-Java-Можно-ли-вызвать-сборку-мусора)
+ [34. Как устроена память в Java?](#34-Как-устроена-память-в-Java)
+ [35. В какой области памяти хранятся локальные переменные и объекты?](#35-В-какой-области-памяти-хранятся-локальные-переменные-и-объекты)
+ [36. Написать код, который 100% приведет к OutOfMemoryError, а также к StackOverflowException](#36-Написать-код-который-100-приведет-к-OutOfMemoryError-а-также-к-StackOverflowException)
+ [37. Что такое happens-before? Приведите примеры.](#37-Что-такое-happens-before-Приведите-примеры)
+ [38. Что такое deadlock? Как его избежать?](#38-Что-такое-deadlock-Как-его-избежать)
+ [39. Что такое состояние гонок?](#39-Что-такое-состояние-гонок)
+ [40. Что такое Executor'ы? Зачем они нужны?](#40-Что-такое-Executor'ы-Зачем-они-нужны)
+ [41. В чем отличия между equals и ==? Контракты по equals и hashcode.](#41-В-чем-отличия-между-equals-и-==-Контракты-по-equals-и-hashcode)
+ [42. написать реализацию equals и хеш-код для произвольного класса](#42-написать-реализацию-equals-и-хеш-код-для-произвольного-класса)
+ [43. Что такое дерево? Можно ли сделать так, чтобы обычное двоичное дерево выродилось в связный список?](#43-Что-такое-дерево-Можно-ли-сделать-так-чтобы-обычное-двоичное-дерево-выродилось-в-связный-список)
+ [44. Какие есть способны конфигурирования ApplicationContext Spring'a.](#44-Какие-есть-способны-конфигурирования-ApplicationContext-Spring'a)
+ [45. Как в Spring заинжектить два бина одного типа?](#45-Как-в-Spring-заинжектить-два-бина-одного-типа)
+ [46. Что такое SpringBoot](#46-Что-такое-SpringBoot)
+ [47. Принципы организации многопоточности в java](#47-Принципы-организации-многопоточности-в-java)
+ [48. Как запустить поток?](#48-Как-запустить-поток)
+ [49. Состояния потоков](#49-Состояния-потоков)
+ [50. SQL](#50-SQL)
+ [51. Транзакции. ACID. Феномены чтения.](#51-Транзакции-ACID-Феномены-чтения)
+ [53. Что такое Maven?](#53-Что-такое-Maven)
+ [53. Что такое область видимости зависимостей DEPENDENCY SCOPE в Maven?](#53-Что-такое-область-видимости-зависимостей-DEPENDENCY-SCOPE-в-Maven)
+ [54. Какие вы знаете репозитории Maven](#54-Какие-вы-знаете-репозитории-Maven)
+ [55. Внутреннее устройство хранилища git](#55-Внутреннее-устройство-хранилища-git)
+ [56. Сервлеты. JSP](#56-Сервлеты-JSP)
+ [57. Spring core](#57-Spring-core)
+ [58. Spring MVC](#58-Spring-MVC)
+ [59. JPA](#59-JPA)
+ [60. Hibernate](#60-Hibernate)
+ [61. Способы аутентификации пользователя](#61-Способы-аутентификации-пользователя)
+ [62. Паттерны. Написать реализацию паттерна Singleton. Abstract Factory vs factory method.](#62-Паттерны-Написать-реализацию-паттерна-Singleton-Abstract-Factory-vs-factory-method)
+ [63. How to define immutable object](#63-How-to-define-immutable-object)
+ [64. Spring DispatcherServlet how it works](#64-Spring-DispatcherServlet-how-it-works)
+ [65. Какие существуют два вида методов для работы со стримами](#65-Какие-существуют-два-вида-методов-для-работы-со-стримами)
+ [66. Чем отличается DI от IoC](#66-Чем-отличается-DI-от-IoC)
+ [67. Что такое бин Spring](#67-Что-такое-бин-Spring)
+ [68. Каков жизненный цикл бина Spring](#68-Каков-жизненный-цикл-бина-Spring)
+ [Algo 1: Binary search recursion](https://dev.to/javinpaul/20-basic-algorithms-problems-from-coding-interviews-4o76)
+ [Algo 2: Binary search without recursion]
+ [Algo 3: Buble sort]
+ [Algo 4: Level Order Search in a Binary Tree]
+ [Algo 5: Difference between a stable and unstable sorting algorithm]
+ [Algo 6: What is Depth First Search Algorithm for a binary tree]
+ [Algo 7: What is Depth First Search Algorithm for a binary tree]
+ [Algo 8: How is an iterative quicksort algorithm implemented]
+ [Algo 9: How do you implement a counting sort algorithm]
+ [Algo 10: How do you swap two numbers without using the third variable]
+ [Algo 11: How is a radix sort algorithm implemented]
+ [Algo 12: How do you implement an insertion sort algorithm]
+ [Algo 13: Write Algorithm to check if two rectangles overlap with each other]
+ [Algo 14: How is a merge sort algorithm implemented]
+ [Algo 15: How do you implement a bucket sort algorithm]
+ [Algo 16: Write Algorithms to Check if Two String are Anagram]
+ [Algo 17: Implement the QuickSort Algorithm in your Favorite Programing language]
+ [Algo 18: Difference between Comparison and Non-Comparison Sorting Algorithms]
+ [Algo 19: How to check if two String is rotations of each other]
+ [Algo 20: Implement Sieve of Eratosthenes Algorithms for Prime Number]

## 1 Что такое java характеристики языка

+ ООП.
+ Строгая типизация.
+ По умолчанию запрет прямого доступа к памяти (исключение sun.misc.Unsafe).
+ Нет множественного наследования классов. Вместо этого интерфейсы.
+ Write once, run anywhere. Не зависит от ОС. Т.к. исползуется JVM.
+ Особенность ява, связанная с транслированием в байт-код, положительно сказывается и на производительности.
+ Многопоточный.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 2 Что значит высокоуровневый язык программирования

Высокоуровневые языки программирования были разработаны для платформенной независимости сути алгоритмов. 
Зависимость от платформы перекладывается на инструментальные программы — трансляторы, компилирующие текст, 
написанный на языке высокого уровня, в элементарные машинные команды (инструкции).

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 3 Какие бывают языки программирования

+ Объектно-ориентированные.
+ Процедурные. Процедуры меняют какое-то общее состояние. 
Процедурный стиль - это использование операторов последовательного исполнения, ветвления и безусловного перехода
```javascript
const array = ['first', 'second'];

let output;

function allOdd(words) {
  let result = true;

  for (let i = 0; i < words.length; ++i) {
    const len = words[i].length;

    if (len % 2 !== 0) {
      result = false;
      break;
    }
  }

  return result;
}

output = allOdd(array);

alert(output);
```
+ Функциональные. ФП не предполагает наличия изменяемого состояния. 
Функциональный стиль - это использование только суперпозиции функций.
 ```javascript
 function length(string) {
   return prop('length', string);
 }
 
 function odd(number) {
   return equals(modulus(number, 2), 0); 
 }
 
 function allOdd(...words) {
   return every(compose(odd, length), words);
 }
 
 alert(allOdd('first', 'second'));
```

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 4 Принципы ООП как реализована инкапсуляция в Java полиморфизм

+ *Абстракция* - выделение значимой информации и исключение из рассмотрения незначимой. В Java: через классы.
+ *Инкапсуляция* - свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе. 
Для Java корректно будет говорить, что инкапсуляция это «сокрытие реализации». В Java: Используются модификаторы доступа public, private, package;
+ *Наследование* - cвойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. 
Класс, от которого производится наследование, называется базовым, родительским или суперклассом. В Java: Extends, Impliments;
+ *Полиморфизм* - свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта. В Java: через интерфейсы;

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 5 Модификаторы доступа

+ private (закрытый) — доступ к члену класса не предоставляется никому, кроме методов этого класса. 
Другие классы того же пакета также не могут обращаться к private-членам.
+ default, package, friendly, доступ по умолчанию, когда никакой модификатор не присутствует — 
член класса считается открытым внутри своего собственного пакета, но не доступен для кода, расположенного вне этого пакета.
Т.е. если package2.Class2 extends package1.MainClass, то в Class2 методы без идентификатора из MainClass видны не будут.
+ protected (защищённый) — доступ в пределах пакета и классов наследников. 
Доступ в классе из другого пакета будет к методам public и protected главного класса. 
Т.е. если package2.Class2 extends package1.MainClass, то внутри package2.Class2 методы с идентификатором protected из MainClass будут видны.
+ public (открытый) — доступ для всех из любого другого кода проекта
+ Модификаторы в списке расположены по возрастающей видимости в программе.
+ Во время наследования возможно изменения модификаторов доступа в сторону большей видимости. 
Так сделано для того, чтобы не нарушался принцип LSP для наследуемого класса.
protected -> public
package -> protected, public

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 6 Принципы SOLID

+ S - Принцип единственной ответственности.  Данный принцип гласит: никогда не должно быть больше одной причины изменить класс.
+ O - Принцип открытости закрытости. Класс должен быть открыт для расширения и закрыт для изменения.
+ L - Принцип подстановки Барбары Лисков. объекты в программе можно заменить их наследниками без изменения свойств программы.
+ I - Принцип разделения интерфейса. Много интерфейсов специального назначения лучше, чем один интерфейс общего назначения.
+ D - Принцип подстановки зависимостей. Зависимость на абстракцию. Нету зависимости на конкретную реализацию.

[SOLID](https://github.com/a11exe/job4j/blob/master/interview_questions/SOLID.md)

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 7 Опишите примитивные типы java

+ byte - 1 байт (8 бит). Мин -2^7 макс 2^7-1
+ short - 2 байта (16 бит). Мин -2^15 Макс 2^15-1
+ char - 2 байта (16 бит). 2^16-1
+ int - 4 байта (32 бит). Мин -2^31-1 Макс 2^31
+ long - 8 байт (64 бит). Мин -2^63-1 Макс 2^63
+ float - 4 байта (32 бит). Мин -2^31-1 Макс 2^31
+ double - 8 байт (64 бит). Мин -2^63-1 Макс 2^63
+ boolean - по спецификации не определен в среднем 1 байт

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 8 Последовательность инициализации блоков класса и его родителя

+ Сначала вызываются все статические блоки от первого предка до последнего наследника. 
+ Потом попарно вызываются динамический блок инициализации и конструктор в той же последовательности (от предка до последнего потомка). 

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 9 Классы внутренние вложенные абстрактные

*Особенности абстрактных классов:*
+ Если есть хоть один абстрактный метод, то класс должен быть абстрактным. 
+ Абстрактные классы нельзя создавать с помощью new, но можно использовать в качестве ссылки, для полиморфизма.

*Вложенный класс (nested classes.)*
+ Non-static nested classes — нестатические вложенные классы. По-другому их еще называют inner classes — внутренние классы.
+ Static nested classes — статические вложенные классы.

*Внутренний класс (inner classes)*
+ локальным классом (local class)
+ анонимным классом (anonymous class)

![Вложенные классы](https://github.com/a11exe/job4j/blob/master/interview_questions/nested.png)

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 10 Замыкания

Лямбда-выражения Java 8 — это замыкания.
Что такое замыкание?
При замыкании используются переменные, расположенные вне области действия функции.
local variables referenced from a lambda expression must be final or effectively final 
(локальные переменные, на которые ставится ссылка из лямбда-выражения, 
должны быть финальными или фактически финальными).

Оказывается, что лямбда-выражения в Java замыкаются только вокруг значений, но не вокруг переменных. 
Java требует, чтобы эти значения были неизменны, как если бы мы объявили их final. 
Итак, они должны быть final независимо от того, объявляли вы их таким образом или нет. 
То есть, «фактически финальными». Поэтому в Java есть «замыкания с ограничениями», 
а не «полноценные» замыкания, которые, тем не менее, довольно полезны.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 11 Методы класса Object

+ public final native Class *getClass()* — возвращает в рантайме класс данного объекта.
+ public native int *hashCode()* — возвращает хеш-код
+ public boolean *equals(Object obj)* — сравнивает объекты.
+ protected native Object *clone()* throws CloneNotSupportedException — клонирование объекта
+ public String *toString()* — возвращает строковое представление объекта.
+ public final native void *notify()* — просыпается один поток, который ждет на “мониторе” данного объекта.
+ public final native void *notifyAll()* — просыпаются все потоки, которые ждут на “мониторе” данного объекта.
+ public final native void *wait(long timeout)* throws InterruptedException — поток переходит в режим ожидания в течение указанного времени.
+ public final void *wait()* throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() методы для этого объекта.
+ public final void *wait(long timeout, int nanos)* throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() для этого метода, или пока не истечет указанный промежуток времени.
+ protected void *finalize()* throws Throwable — вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 12 Ключевое слово volatile Понятие атомарной операции и как это связано с volatile

**volatile** - этот модификатор вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной. 
Если переменная примитивного типа – этого будет достаточно для обеспечения потокобезопасности. 
Если же переменная является ссылкой на объект – синхронизировано будет исключительно значение этой ссылки. 
Все же данные, содержащиеся в объекте, синхронизированы не будут!

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 13 Финализация объектов в Java

Called by the garbage collector on an object when garbage collection determines that there are no more references to the object.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 14 Иерархия коллекций

+ i Collections extends Iterable.
+ \- i *Set* (коллекция без дублирования)
+ -- HashSet базирующаяся на HashMap В качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object())
+ --- LinkedHashSet в основе лежит LinkedHashMap
+ -- i SortedSet Методы: first, last
+ --- TreeSet (отсортированный список) содержит в себе объект NavigableMap
+ \- i Queue очередь Методы: offer(), element(), peek(), poll(), remove()
+  -- i Deque двусторонняя очередь addFirst, addLast, getFist, getLast, (push, pop  -> использовать как стек)
+ \- i *List* упорядоченная коллекция (сохраняет последовательность элементов. можно получить по индексу, можно повторяющиеся, можно по значению первый найденный)
+ -- Vector @deprecated реализация динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента
+ -- Stack - данная коллекция является расширением коллекции Vector. реализация стека LIFO
+ -- ArrayList динамический массив, можно хранить null
+ -- LinkedList связный список (impl List & Deque)
+ i *Map* (нет итератора, нельзя перебирать в цикле. Можно получить представление в виде коллекции для перебора) get(), put(), entrySet(), keySet(), values()
+ \- i SortedMap (по порядку нарастания ключей)
+ \- i NavigableMap
+ -- TreeMap реализация Map основанная на красно-чёрных деревьях (отсортированная по умолчанию natural odering, можно задать свой компаратор)
+ \- AbstractMap
+ -- HashMap позволяет использовать null как в качестве ключа, так и значения
+ --- LinkedHashMap  это упорядоченная реализация хэш-таблицы. Аналогично LinkedList
+ \- WeekHashMap - реализация хэш-таблицы, которая организована с использованием weak references. 
Другими словами, Garbage Collector автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элеметна нет жёстких ссылок

![collection](https://github.com/a11exe/job4j/blob/master/interview_questions/O.png)					   

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 15 Отличие Set от List приведите примеры реализаций

+ **Set** - Множество. (Здесь могут храниться только уникальные значения, нет дубликатов)
+ **Queue (Deque)** - Очередь. FIFO (Первый вошел, первый вышел). реализуется LinkedList'ом
+ **List** - Упорядоченное хранение данных. (В какой последовательности данные положили, в такой они и хранятся)
+ **Map** - (от Collection он не наследуется) Значения хранятся как пара - ключ-значение. и по ключу получаем значение.
у мапы нету итератора

+ **List**: ArrayList, LinkedList
+ **Set**: HashSet, LinkedHashSet, TreeSet
+ **Map**: HashMap, LinkedHashMap, TreeMap

+ **HashSet** хранит данные в произвольном порядке (хранит свои значения как ключи HashMap).
+ **TreeSet** хранит данные в отсортированном виде (бинарное дерево).

сет это список ключей от мапы

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 16 Когда имеет смысл использовать LinkedList вместо ArrayList

**ArrayList** реализован на массивах. (используют если чаще читаются элементы, чем добавляются)
Хранит свои элементы в массиве.
+ \+ осуществляется быстрый поиск элементов.
+ \+ меньше расходует памятина хранение элементов
+ \- увеличение ArrayList'a происходит медленно.
+ \- при вставке элемента (или удалении) в середину или в начало, приходится переписывать все элементы.

**LinkedList** является представителем двунаправленного списка. (цепочка) 
(используется если элементы чаще добавляются чем читаются)
Хранит свои элементы в обектах у которых есть ссылки на предыдущий и следующий элементы.
+ \+ быстрая вставка и удаление в середину списка (переписать next и prev и всё)
+ \- долгий поиск в середине (нужно перебрать все элементы)

в среднем, сложности одинаковые. Но я бы не стал рекомендовать использовать LinkedList,
за исключением ситуации когда, преобладает удаление или вставка в начало или конец списка.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 17 Устройство HashMap

HashMap состоит из «корзин» (bucket`ов). С технической точки зрения «корзины» — это элементы массива, 
которые хранят ссылки на списки элементов. При добавлении новой пары ключ-значение, вычисляет хеш-код ключа, 
на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. 
Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, 
то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, 
от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, 
то он заменяется. Добавление, поиск и удаление элементов выполняется за константное время. Вроде все здорово, с одной оговоркой, 
хеш-функций должна равномерно распределять элементы по корзинам, 
в этом случае временная сложность для этих 3 операций будет не ниже lg N, а в среднем случае как раз константное время.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 18 Итераторы Можно ли удалить элемент из коллекции в итерации цикла по коллекции

Удалять надо используя итератор для обхода. Иначе будет ConcurrentModificationException.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 19 Что такое fail fast и fail safe

[Сравнение итераторов](https://www.codeflow.site/ru/article/java-fail-safe-vs-fail-fast-iterator)

Fail-fast итератор генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, а fail-safe – нет.

Важно отметить, что fail-fast итераторы работают на основе принципа "по мере возможности", 
то есть не дается никаких гарантий генерации исключения ConcurrentModificationException в случае конкурентной модификации. 
Так что полагаться на это не стоит – скорее, их следует использовать для обнаружения ошибок. 
Большинство неконкурентных коллекций предоставляют fail-fast итераторы.

fail-safe итераторы используются в конкурентных коллекциях ConcurrentHashMap

+ Эти итераторы создают клон фактической Collection и перебирают его
+ Они могут обрабатываться конкурентно с другими операциями
+ Они никогда не генерируют исключение ConcurrentModificationException
+ Они гарантированно обходят существовавшие на момент создания итератора элементы ровно один раз, и могут (но не обязаны) отражать последующие модификации.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 20 Механизм сериализации в Java его внутреннее устройство

Интерфейс маркер Serializable. Для записи обьекта используется ObjectOutputStream с private методом writeObject() для чтения ObjectInputStream с методом private readObject()
Thread, OutputStream и его подклассы, и Socket - не сериализуемые
Transient - помечает объект который сериализовать не нужно.
Если мы не хотим сериализовать наследника чей супер класс помечен Serializable то в этом наследнике переопределив методы writeObject() и readObject() кидаем throw new NotSerializableException();

Интерфейс Externalizable содержит 2 метода 
public void writeExternal(ObjectOutput out) throws IOException;
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;
serialVersionUID - версионность сериализованного объекта (например избавляет от проблемы когда добавил новое поле, пытаемся десериализовать данный объект из сохраненного ранее состояния и получаем InvalidClassException)

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 21 Клонирование в Java

Можно использовать конструктор копирования.

В Java это означает возможность создавать объект с аналогичной структурой, как и у исходного объекта. 
Метод clone() обеспечивает эту функциональность.

Поверхностное копирование копирует настолько малую часть информации, насколько это возможно. 
По умолчанию, клонирование в Java является поверхностным, т.е. Object class не знает о структуре класса, которого он копирует. 
*При клонировании, JVM делает такие вещи:*   
+ Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект.
+ Если класс содержит не только члены примитивных типов, а и любого другого типа класса, тогда копируются ссылки на объекты этих классов. 
Следовательно, оба объекта будут иметь одинаковые ссылки.
Глубокое копирование дублирует все. 
Глубокое копирование — это две коллекции, в одну из которых дублируются все элементы оригинальной коллекции. 
Мы хотим сделать копию, при которой внесение изменений в любой элемент копии не затронет оригинальную коллекцию. 

*Глубокое клонирование требует выполнения следующих правил:*
+ Нет необходимости копировать отдельно примитивные данные;
+ Все классы-члены в оригинальном классе должны поддерживать клонирование. 
Для каждого члена класса должен вызываться super.clone() при переопределении метода clone();
+ Если какой-либо член класса не поддерживает клонирование, 
то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, 
по одному.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 22 StringBuffer vs StringBuilder

StringBuffer is synchronized, StringBuilder is not.
StringBuilder is faster than StringBuffer because it's not synchronized.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 23 Методы обработки XML документов

+ *DOM* - обход XML документа в оба направлениях, грузит весь документ в память подходит для небольших файлов.
Cчитывает сразу весь XML и сохраняет его, создавая иерархию в виде дерева, 
по которой мы можем спокойно двигаться и получать доступ к нужным нам элементам.
[DOM](https://javarush.ru/groups/posts/656-konkurs-osnovih-xml-dlja-java-programmista---chastjh-31-iz-3---dom)
+ *Stax* - событийный, грузит документ частями, подходит для мелких документов. работает по пул модели. 
Позволяет обрабатывать только те события которые нам необходимы. позволяет писать в XML файл.
+ *Sax* - событийный, грузит документ частями, позволяет работать с большими документам, 
работает по пуш модели необходимо обрабатывать все события.
[Sax](https://javarush.ru/groups/posts/650-konkurs-osnovih-xml-dlja-java-programmista---chastjh-31-iz-3---sax)

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 24 Особенности Java 8

+ Лямбды и Функциональные интерфейсы
+ Интерфейсы по умолчанию и статические методы
+ Ссылочные методы cars.forEach( Car::repair )

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 25 Зачем нужны лямбды

+ Лямбда-выражение представляет собой блок кода, который можно передать в другое место, 
поэтому он может быть выполнен позже, один или несколько раз.
+ Они позволяют написать метод и сразу же использовать его. 
Особенно полезно в случае однократного вызова метода, т.к. сокращает время на объявление и написание метода без
необходимости создавать класс.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 26 Зачем нужны исключения

Раньше использовались коды возврата:

+ Нельзя было пробрасывать между методами. Приходилось обрабатывать в каждом.
+ Не всегда можно было точно понять какая конкретно ошибка.

На стадии разработки программы мы «ограждаем» опасные участки кода в отношении исключений с помощью блока try{}, 
предусматриваем «запасные» пути с помощью блока catch{}, 
в блоке finally{} мы пишем код, который выполняется в программе при любом исходе.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 27 Иерархия исключений Отличия checked от unchecked исключений Назвать некоторые checked и unchecked исключения

Все исключения наследуются от Throwable.

+ Error (unchecked)- восстановление дальнейшей нормальной работы программы невозможно. 
+ Exception
++ RuntimeException (unchecked) - NPE, ClasCastEx, 
++ Checked Exception (checked) - IOEx, SQLEx

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 28 Как определить свою аннотацию

Аннотации используются для анализа кода, компиляции или выполнения. 
Аннотированы могут быть пакеты, классы, методы, переменные и параметры.

Для этого вам нужно создать новый тип, который использует Java тип @interface, 
который будет содержать элементы, которые в свою очередь определяют детали метаданных.

 ```java
public @interface About{
    String info() default "";
}
 ```
 
[к оглавлению](#Вопросы-для-собеседования-минимум)

## 29 Зачем нужны immutable объекты

Неизменяемые объекты можно свободно использовать одновременно из разных нитей.
Обычно immutable классы содержат различные методы, которые «как бы» меняют объект, 
но вместо изменения самого объекта эти методы просто создают новый объект и возвращают его.

В случае же immutable-объекта объект после окончания конструктора не изменяется вообще. 
Одного лишь модификатора final для этого недостаточно, необходимо, чтобы все подбъекты были тоже неизменяемыми. 
Вы в принципе можете держать внутри ссылку на изменяемый объект, но обращаться с ним так, чтобы он не менялся.

неизменяемые объекты не требуют синхронизации при многопоточном доступе.

To create an immutable class in java, you have to do following steps.

+ Declare the class as final so it can’t be extended.
+ Make all fields private so that direct access is not allowed.
+ Don’t provide setter methods for variables
+ Make all mutable fields final so that it’s value can be assigned only once.
+ Initialize all the fields via a constructor performing deep copy.
+ Perform cloning of objects in the getter methods to return a copy rather than returning the actual object reference.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 30 Назовите паттерны проектирования которые вы использовали

+ *Builder* - StringBulider
+ *Factory Method* (Фабрика)- Calendar calendar = Calendar.getInstance(); 
(Если мы посмотрим в конструктор, то увидим, что в зависимости от условий создаются разные реализации Calendar)
Возвращает объекты через абстрактные типы или интерфейсы. Необходим для ликвидирования зависимости кода от создания конкретных объектов.
+ *Abstract Factory* - Абстрактная фабрика предоставляет интерфейс для создания целых семейств объектов без указания конкретных классов. 
Объекты каждого семейства должны быть логически связаны между собой. Паттерн можно определить по методам, 
возвращающим фабрику, которая, в свою очередь, используется для создания конкретных продуктов, возвращая их через абстрактные типы или интерфейсы.
+ *Singleton* - Изначально, как замена глобальным переменным. Он один и следовательно все обращения к нему несут изменения во всём проекте. 
В одном месте вы создали подключение к базе и дальше можете уже использовать его в любой части программы, 
не пересоздавая подключение и не передавая каждый раз его как аргумент функции.
Not Lazy (потокобезопасная)
```java
public class Singleton {
	public static final Singleton INSTANCE = new Singleton();
}
```
LAZY
+ *Decorator (Wrapper)* - декоратор оборачивается вокруг чего-то, что передали на вход. 
Было побайтовое чтение, раз и добавили оберткой буферизацию, а потом еще что-нибудь
+ *Adapter* - Он похож на декоратор — на вход декоратор принимает один объект и возвращает обёртку над этим объектом. 
Отличие в том, что цель у этого не изменение функционала, а адаптация одного интерфейса к другому. 

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 31 Scope'ы бинов в Spring'e

+ *singleton* Определяет один единственный бин для каждого контейнера Spring IoC (используется по умолчанию).
+ *prototype* Позволяет иметь любое количество экземпляров бина. Spring does not manage the complete lifecycle of a prototype bean: the container instantiates, configures, decorates and otherwise assembles a prototype object, hands it to the client and then has no further knowledge of that prototype instance.
This means that while initialization lifecycle callback methods will be called on all objects regardless of scope, in the case of prototypes, any configured destruction lifecycle callbacks will not be called.
+ *request* Создаётся один экземпляр бина на каждый HTTP запрос. Касается исключительно ApplicationContext.
+ *session* Создаётся один экземпляр бина на каждую HTTP сессию. Касается исключительно ApplicationContext.
+ *global-session* Создаётся один экземпляр бина на каждую глобальную HTTP сессию. Касается исключительно ApplicationContext.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 32 Какие книги читали по Java

+ Head first
+ Герберт Шилдт. Java 8. Руководство для начинающих

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 33 Как работает сборщик мусора в Java Можно ли вызвать сборку мусора

JVM обычно запускает сборщик мусора при низком уровне свободной памяти. 
Но работа сборщика мусора не гарантирует, что всегда будет оставаться достаточно свободной памяти.
Если памяти недостаточно даже после восстановления, JVM генерирует исключение OutOfMemoryError. 
Обратите внимание, что перед генерированием исключения JVM обязательно запускает сборщик мусора как минимум 1 раз.

System.gc()
Runtime.getRuntime().gc()

Объект может подлежать утилизации в разных случаях:
+ Если переменная ссылочного типа, которая ссылается на объект, установлена в положение "0", 
объект подлежит утилизации, в том случае, если на него нет других ссылок.
+ Если переменная ссылочного типа, которая ссылается на объект, создана для ссылки на другой объект, 
объект подлежит утилизации, в том случае, если на него нет других ссылок.
+ Объекты, созданные локально в методе, подлежат утилизации, когда метод завершает работу, 
если только они не экспортируются из этого метода (т.е, возвращаются или генерируются как исключение).
+ Объекты, которые ссылаются друг на друга, могут подлежать утилизации, если ни один из них не доступен живому потоку.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 34 Как устроена память в Java

Для оптимальной работы приложения JVM делит память на область стека (stack) и область кучи (heap).
*Stack*
+ Он заполняется и освобождается по мере вызова и завершения новых методов
+ Переменные в стеке существуют до тех пор, пока выполняется метод в котором они были созданы
+ Если память стека будет заполнена, Java бросит исключение java.lang.StackOverFlowError
+ Доступ к этой области памяти осуществляется быстрее, чем к куче
+ является потокобезопасным, поскольку для каждого потока создается свой отдельный стек

*Heap*
+ Эта область памяти используется для объектов и классов. 
Новые объекты всегда создаются в куче, а ссылки на них хранятся в стеке.
+ Когда эта область памяти полностью заполняется, Java бросает java.lang.OutOfMemoryError
+ Доступ к ней медленнее, чем к стеку
+ Эта память, в отличие от стека, автоматически не освобождается. 
Для сбора неиспользуемых объектов используется сборщик мусора
+ В отличие от стека, куча не является потокобезопасной и ее необходимо контролировать, правильно синхронизируя код
  + *Young Generation* — область где размещаются недавно созданные объекты. 
Когда она заполняется, происходит быстрая сборка мусора
  + *Old (Tenured) Generation* — здесь хранятся долгоживущие объекты. 
Когда объекты из Young Generation достигают определенного порога "возраста", они перемещаются в Old Generation
  + *Permanent Generation* — эта область содержит метаинформацию о классах и методах приложения, 
но начиная с Java 8 данная область памяти была упразднена.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 35 В какой области памяти хранятся локальные переменные и объекты

Новые объекты всегда создаются в куче, а ссылки на них хранятся в стеке.
variables of a method are stored in stack and class variables are stored in heap.
Локальные переменные в стеке. Объекты в куче.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 36 Написать код который 100 приведет к OutOfMemoryError а также к StackOverflowException

*OutOfMemoryError*
```java
List<long[]> list = new LinkedList<long[]>();
while (true) {
  list.add(new long[65536]); // an arbitrary number
  // sleep(1) perhaps?
}
```

*StackOverflowException*
```java
public class StackOverflowErrorExample {

    public static void recursivePrint(int num) {
        System.out.println("Number: " + num);

        if(num == 0)
            return;
        else
            recursivePrint(++num);
    }

    public static void main(String[] args) {
        StackOverflowErrorExample.recursivePrint(1);
    }
}
```

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 37 Что такое happens before Приведите примеры

Пусть есть поток X и поток Y (не обязательно отличающийся от потока X). 
И пусть есть операции A (выполняющаяся в потоке X) и B (выполняющаяся в потоке Y).

В таком случае, A happens-before B означает, что все изменения, выполненные потоком X до момента операции A и изменения,
которые повлекла эта операция, видны потоку Y в момент выполнения операции B и после выполнения этой операции.

вот некоторые условия синхронизации памяти:

+ В рамках одной нити любая команда happens-before (читается «случается перед») любой операцией, 
следующей за ней в исходном коде.
+ Освобождение лока (unlock) happens-before захватом того же лока (lock).
+ Выход из synchronized блока/метода happens-before вход в synchronized блок/метод на том же мониторе.
+ Запись volatile поля happens-before чтение того же самого volatile поля.
+ Завершение метода run экземпляра класса Thread happens-before выход из метода join() 
или возвращение false методом isAlive() экземпляром той же нити.
+ Вызов метода start() экземпляра класса Thread happens-before начало метода run() экземпляра той же нити.
+ Завершение конструктора happens-before начало метода finalize() этого класса
+ Вызов метода interrupt() на нити happens-before, когда нить обнаружила, что данный метод был вызван, 
либо путем выбрасывания исключения InterruptedException, либо с помощью методов isInterrupted() или interrupted()

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 38 Что такое deadlock Как его избежать

Взаимная блокировка (deadlock) - явление при котором все потоки находятся в режиме ожидания.
Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. Этого можно достичь, 
получая мониторы разделяемых ресурсов в определённом порядке и освобождая их в обратном порядке.

+ **Взаимная блокировка порядка синхронизации**
```java
public void transferMoney(Account fromAccount, Account toAccount, Amount amount) throws InsufficientFundsException {
	synchronized (fromAccount) {
		synchronized (toAccount) {
			if (fromAccount.getBalance().compareTo(amount) < 0)
				throw new InsufficientFundsException();
			else {
				fromAccount.debit(amount);
				toAccount.credit(amount);
			}
		}
	}
```

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 39 Что такое состояние гонок

**Состояние гонки (race condition)** - ошибка проектирования многопоточной системы или приложения, 
при которой эта работа напрямую зависит от того, в каком порядке выполняются потоки. 
Состояние гонки возникает когда поток, который должен исполнится в начале, проиграл гонку и первым исполняется другой поток: 
поведение кода изменяется, из-за чего возникают недетерменированные ошибки.

Распространённые способы решения:

+ Использование локальной копии — копирование разделяемой переменной в локальную переменную потока. 
Этот способ работает только тогда, когда переменная одна и копирование производится атомарно (за одну машинную команду), 
использование volatile.
+ Синхронизация - операции над разделяемым ресурсом происходят в синхронизированном блоке (при использовании ключевого слова synchronized).
+ Комбинирование методов - вышеперечисленные способы можно комбинировать, копируя «опасные» переменные в синхронизированном блоке. 
С одной стороны, это снимает ограничение на атомарность, с другой — позволяет избавиться от слишком больших синхронизированных блоков.
Очевидных способов выявления и исправления состояний гонки не существует. 
Лучший способ избавиться от гонок — правильное проектирование многозадачной системы.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 40 Что такое Executor'ы Зачем они нужны

Начиная с Java 1.5 Java API предоставляет фреймворк Executor, который позволяет создавать различные типы пула потоков:

+ Executor - упрощенный интерфейс пула, содержит один метод для передачи задачи на выполнение;
+ ExecutorService - расширенный интерфейс пула, с возможностью завершения всех потоков;
+ AbstractExecutorService - базовый класс пула, реализующий интерфейс ExecutorService;
+ Executors - фабрика объектов связанных с пулом потоков, в том числе позволяет создать основные типы пулов;
+ ThreadPoolExecutor - пул потоков с гибкой настройкой, может служить базовым классом для нестандартных пулов;
+ ForkJoinPool - пул для выполнения задач типа ForkJoinTask;
+ ... и другие.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 41 В чем отличия между equals и == Контракты по equals и hashcode

Метод equals() обозначает отношение эквивалентности объектов. Эквивалентным называется отношение, которое является симметричным, транзитивным, рефлексивным и постоянным.
1. Рефлексивность: для любого ненулевого x, x.equals(x) вернет true;
2. Транзитивность: для любого ненулевого x, y и z, если x.equals(y) и y.eqals(z) вернет true, тогда и x.equals(z) вернет true;
3. Постоянство: для любых объектов x и y x.equals(y) возвращает одно и тоже, если информация, используемая в сравнениях, не меняется;
4. Симметричность: для любого ненулевого x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) вернет true.

Метод хешкод
Если хешкод двух объектов равен - это не значит что 2 объекта равны по equals
Если хешкод двух объектов не равен - значит объекты не равны по equals

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 42 написать реализацию equals и хеш код для произвольного класса

```java
    @Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + varA;
		result = prime * result + varB;
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		BlackBox other = (BlackBox) obj;
		if (varA != other.varA)
			return false;
		if (varB != other.varB)
			return false;
		return true;
	}
```

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 43 Что такое дерево Можно ли сделать так чтобы обычное двоичное дерево выродилось в связный список

На самом, деле, как выше упоминалось в основе TreeSet лежит красно-черное дерево, 
которое умеет само себя балансировать. В итоге, TreeSet все равно в каком порядке вы добавляете в него элементы, 
преимущества этой структуры данных будут сохраняться.
Чтобы выродилось в связный список у всех объектов должен быть одинаковый хешкод.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 44 Какие есть способны конфигурирования ApplicationContext Spring'a

[3 ways to configure the Spring Container](https://stackoverflow.com/questions/35807056/how-many-ways-are-there-to-configure-the-spring-framework-what-are-the-differen)
+ XML - based configuration
+ Java Based Configuration (In this Configuration method, there will be a class for the configuration)
+ Annotation Based Configuration

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 45 Как в Spring заинжектить два бина одного типа

@Autowired
@Qualifier("jdbcDeviceDao")

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 46 Что такое SpringBoot

*Spring Boot* — это полезный проект, целью которого является упрощение создания приложений на основе Spring. 
Он позволяет наиболее простым способом создать web-приложение, 
требуя от разработчиков минимум усилий по его настройке и написанию кода.
Чтобы ускорить процесс управления зависимостями, Spring Boot неявно упаковывает необходимые сторонние зависимости 
для каждого типа приложения на основе Spring и предоставляет их разработчику посредством так называемых 
starter-пакетов (spring-boot-starter-web, spring-boot-starter-data-jpa и т.д.)

Starter-пакеты представляют собой набор удобных дескрипторов зависимостей, которые можно включить в свое приложение.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 47 Принципы организации многопоточности в java

**Процесс** - это Отдельно запущенное приложение и у него есть своя область памяти (минимум 1 поток).

**Поток** - это паралельные нити выполнения внутри одного процесса которые разделяют общую память.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 48 Как запустить поток

+ Создать потомка класса Thread и переопределить его метод run();
+ Создать объект класса Thread, передав ему в конструкторе экземпляр класса, реализующего интерфейс Runnable. 
Эти интерфейс содержит метод run(), который будет выполняться в новом потоке. 
Поток закончит выполнение, когда завершится его метод run().
+ Вызвать метод submit() у экземпляра класса реализующего интерфейс ExecutorService, 
передав ему в качестве параметра экземпляр класса реализующего интерфейс Runnable или Callable (содержит метод call(), в котором описывается логика выполнения).

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 49 Состояния потоков

Потоки могут находиться в одном из следующих состояний:

+ Новый (New). После создания экземпляра потока, он находится в состоянии Новый до тех пор, пока не вызван метод start(). 
В этом состоянии поток не считается живым.
+ Работоспособный (Runnable). Поток переходит в состояние Работоспособный, когда вызывается метод start(). 
Поток может перейти в это состояние также из состояния Работающий или из состояния Блокирован. 
Когда поток находится в этом состоянии, он считается живым.
+ Работающий (Running). Поток переходит из состояния Работоспособный в состояние Работающий, 
когда Планировщик потоков выбирает его как работающий в данный момент.
+ Живой, но не работоспособный (Alive, but not runnable). Поток может быть живым, но не работоспособным по нескольким причинам:
+ Ожидание (Waiting). Поток переходит в состояние Ожидания, вызывая метод wait(). Вызов notify() или notifyAll() может перевести поток из состояния Ожидания в состояние Работоспособный.
+ Сон (Sleeping). Метод sleep() переводит поток в состояние Сна на заданный промежуток времени в миллисекундах.
+ Блокировка (Blocked). Поток может перейти в это состояние, в ожидании ресурса, такого как ввод/вывод или из-за блокировки другого объекта. В этом случае поток переходит в состояние Работоспособный, когда ресурс становится доступен.
+ Мёртвый (Dead). Поток считается мёртвым, когда его метод run() полностью выполнен. Мёртвый поток не может перейти ни в какое другое состояние, даже если для него вызван метод start().

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 50 SQL

*Чем отличаются реляционные БД от нереляционных?*

+ *Реляционные базы* -  хранят данные в таблицах, в которых строки соответствуют разным записям, а колонки разным полям.
+ *Нереляционные базы* -  это все остальные. Некоторые из них хранят записи в виде больших наборов "ключ-значение"

*Какие ключи бывают в БД?*

+ первичный ключ;
+ внешний ключ;
+ простой; 
+ составной ключ;

*Что такое агрегатные функции?*

Агрегатная функция выполняет вычисление на наборе значений и возвращает одиночное значение. 
Агрегатные функции, за исключением COUNT, не учитывают значения NULL. 
Агрегатные функции часто используются в выражении GROUP BY инструкции SELECT.

*LEFT, RIGHT, INNER JOIN чем отличаются?*

Основное различие в том, как соединяются таблицы, если нет общих записей.
+ Простой JOIN - тоже самое что INNER JOIN и означает показывать только общие записи обоих таблиц. Каким образом записи считаются общими определяется полями в join-выражении. Например следующая запись
 ```sql
 FROM t1 JOIN t2 on t1.id = t2.id
 ``` 
означает что будут показаны записи с одинаковыми id, существующие в обоих таблицах.
+ LEFT JOIN (или LEFT OUTER JOIN) означает показывать все записи из левой таблицы (той, которая идет первой в join-выражении) независимо от наличия соответствующих записей в правой таблице.
+ RIGHT JOIN (или RIGHT OUTER JOIN) действует в противоположность LEFT JOIN - показывает все записи из правой (второй) таблицы и только совпавшие из левой (первой) таблицы.

*Что такое GROUP BY?*

Предложение GROUP BY используется для определения групп выходных строк, к которым могут применяться агрегатные функции (COUNT, MIN, MAX, AVG и SUM).

*Чем отличаются HAVING от WHERE?*

Основное отличие WHERE от HAVING заключается в том, что WHERE сначала выбирает строки, 
а затем группирует их и вычисляет агрегатные функции (таким образом, она отбирает строки 
для вычисления агрегатов), 
тогда как HAVING отбирает строки групп после группировки и вычисления агрегатных функций.  

[SQL](https://github.com/a11exe/job4j/blob/master/interview_questions/SQL.md#sql)

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 51 Транзакции ACID Феномены чтения

*Транзакции*
___________________
ACID принципы
+ 1. Атомарность - Все операции либо будут выполнены вместе либо не выполнены вообще.
+ 2. Консистентность - После коммита в БД сохраняются все изменения.
+ 3. Изолированность - Изоляция от внешних воздействий / паралельных транзакций.
+ 4. Надежность - Даже после выключения света все данные останутся в БД

*Феномены чтения*
+ Unrepeatable read(Неповторяемость чтения) - Ситуация когда транзакция которая уже получила данные видит уже измененные данные другой транзакции при повторном запросе
+ Фантомное чтение - Ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.
+ Грязное чтение - Чтение/Добавление/Изменение данных транзакции которая откатиться

*Уровни изоляций*
+ Read-uncommited - Чтение незафиксированных данных
+ Read-commited - Чтение зафиксированных данных
+ Repetable-read - Повторяемость чтения
+ Serializable - Упорядочиваемость. Самый медленный спасает от всех проблем
https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0) - читать

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 53 Что такое Maven

Apache Maven — фреймворк для автоматизации сборки проектов на основе описания их структуры в файлах на языке POM 
(англ. Project Object Model), являющемся подмножеством XML

+ Концентрирование информации о модуле в одном месте и в одном формате. многие IDE могут импортировать проекты из POM.
+ Единая система идентификации модулей.
+ Один инструмент. Хотя это, прямо скажем, не уникальная фича Maven. проект должен собираться стандартными и переносимыми средствами. 
Сборка любимой IDE Первого Разработчика Проекта — путь в ад.
+ Автоматическое управление зависимостями.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 53 Что такое область видимости зависимостей DEPENDENCY SCOPE в Maven

+ *compile* - область видимости по умолчанию. Используется, когда область видимости явно не указана. 
Компилирует зависимости, доступные во всех classpath проекта.
+ *provided* - эта область видимости очень похожа на compile, но показывает, 
что JDK или среда исполнения должна предоставить эти зависимости во время выполнения.
+ *runtime* - показывает, что зависимость не нужна для компиляции, но нужна во время выполнения.
+ *test* - показывает, что эти зависимости не нужны для работы приложения и используются только в фазе тестирования.
+ *system* - очень похожа на provided за исключением того, что вы предоставите архив, который содержит эту зависимость. 
Артефакт всегда доступен, поэтому его поиск в репозитории не производится.
+ *import* (Maven версии 2.0.9 или выше) - эта область видимости используется только в зависимости типа pom в 
секции <dependencyManagement>. 
Она показывает, что указанный pom должен быть заменён зависимостями из pom'a, который указан в dependencyManagement.

provided - For example, all web containers (eg: tomcat) include the jars for servlets. 
You should use provided for the servlet classes so you can compile your code locally, 
but you don't want to override the servlet classes that tomcat provides for you when you deploy to it.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 54 Какие вы знаете репозитории Maven

Существует три типа репозиториев Maven:

+ локальные (local)
+ центральные (central)
+ удалённые (remote)

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 55 Внутреннее устройство хранилища git

![git](https://github.com/a11exe/job4j/blob/master/interview_questions/git.jpg)

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 56 Сервлеты JSP

*Servlet API* - спецификация java расширяющая возможности сервлет контейнера позволяющая обрабатывать HTTP запросы клиента
_______________
жизненный цикл сервлета состоит из следующих шагов:

+ В случае отсутствия сервлета в контейнере.
Класс сервлета загружается контейнером.
Контейнер создает экземпляр класса сервлета.
+ Контейнер вызывает метод init(). 
Этот метод инициализирует сервлет и вызывается в первую очередь, до того, как сервлет сможет обслуживать запросы. 
За весь жизненный цикл метод init() вызывается только один раз.
+ Обслуживание клиентского запроса. Каждый запрос обрабатывается в своем отдельном потоке. 
Контейнер вызывает метод service() для каждого запроса. 
Этот метод определяет тип пришедшего запроса и распределяет его в соответствующий этому типу метод для обработки запроса. 
Разработчик сервлета должен предоставить реализацию для этих методов. 
Если поступил запрос, метод для которого не реализован, вызывается метод родительского класса и обычно завершается возвращением ошибки инициатору запроса.
+ В случае если контейнеру необходимо удалить сервлет, он вызывает метод destroy(), который снимает сервлет из эксплуатации. Подобно методу init(), этот метод тоже вызывается единожды за весь цикл сервлета.

loadOnStartUp в web.xml
также Сервлет АПИ поддерживает фильтры(метод doFilter) и слушатели событий (можно использовать для инициализации при загрузке приложения)

*Java Server Pages* - спецификация
______________________
Технология позволяющая веб-разработчикам создавать содержимое, которое имеет как статические так и динамические компоненты
Код JSP в рантайме компилируется в обычный Servlet а потом джава машина его компилирует в байт код
Внутри JSP можно использовать EL/Скриплеты/taglibs для написание кода 

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 57 Spring core

Фреймворк для упрощения разработки энтерпрайз приложений. 
Построен на принципе IOC (Инверсии управления) Использует для этого контейнер джава бинов. 
Джава бин класс жизненным циклом которого управляет спринг. 
Также спринг использует подход DI Внедрение зависимости используются аннотации @Authowired 
внедрять можно на поля сеттеры конструкторы / аннотации наследники @Component (@Service / @Repository / @Controller)
Также используются и другие аннотации например @Qualifier для уточнения реализации которую необходимо внедрить
У спринг бинов существуют следующие скоупы:
+ 1. *Singleton* - Возвращает один и тот же экземляр бина на каждый запрос контейнера Spring IoC (по умолчанию).
+ 2. *Prototype* - Создает и возвращает новый экземляр бина на каждый запрос.
+ 3. *Request* - Создает и возвращает экземляр бина на каждый HTTP запрос*.
+ 4. *Session* - Создает и возвращает экземляр бина для каждой HTTP сессии*.
+ 5. *Global-session* - Создает и возвращает экземляр бина для глобальной HTTP сессии*.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 58 Spring MVC

DispatcherServlet - основной контроллер фреймворка отвечающий за мапинг запросов на методы контроллеров
Основные используемые аннотации @RestController / @Controller
+ [@RequestMapping](https://java.fandom.com/ru/wiki/@RequestMapping) - позволяет задать шаблон маппинга URI в методе обработчике контроллера.
Можно задать для всего класса или для отдельного метода.
```java
@Controller
@RequestMapping("/my/special/path")
public class SomeController {
  @RequestMapping("/somedata")
  public String loadSomeData() {
    //---
  }
}
```
+ [@RequestBody](https://java.fandom.com/ru/wiki/@RequestBody) - тело запроса может быть распознано как параметр в методе контроллера.
```java
@RequestMapping(value = "/page", method = RequestMethod.POST)
public String savePage(@RequestBody String pageContent) {
  //---
}
```
+ [@ResponceBody](https://java.fandom.com/ru/wiki/@ResponseBody) -  результат работы метода в контроллере в тело ответа.
Аннотация @ResponseBody дает фреймворку понять, что объект, 
который вы вернули из метода надо прогнать через HttpMessageConverter, чтобы получить готовое к отправке на клиент представление.
У Spring есть список HttpMessageConverters. 
HttpMessageConverter обязан конвертировать тело запроса к определенному классу и и класс к телу ответа, 
в зависимости от типа. Каждый раз, когда происходит запрос с аннотацией @ResponseBody, Spring ищет  среди всех HttpMessageConverters подходящий и использует его.
```java
@RequestMapping(value = "/page", method = RequestMethod.POST)
@ResponseBody
public String savePage(@RequestBody String pageContent) {
  //---
}
```
+ [@PathVariable](https://java.fandom.com/ru/wiki/@PathVariable) - параметры методов включены в путь.
```java
@RequestMapping(value = "/pages/{id}")
public String loadPage(@PathVariable(value = "id") Long id) {
  //---
}
``` 
+ [@RequestParam](https://java.fandom.com/ru/wiki/@RequestParam) - параметры методов как параметры запроса.
```java
@RequestParam(value="param1", required=true) String param1,
        @RequestParam(value="param2", required=false) String param2){
	...
```

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 59 JPA

Основные аннотации @Entity @Column @Table @Embedable @MappedSupperClass @Id @ManyToMany @ManyToOne @OneToMany
*EntityManager* - интерфейс содержащий основные операции над сущностями (persist / refresh / detach/ remove / merge)

![jpa](https://github.com/a11exe/job4j/blob/master/interview_questions/jpa.jpg)

[Управления сущностями JPA](https://easyjava.ru/data/jpa/jpa-entitymanager-upravlyaem-sushhnostyami/)

```java
@Entity
@Table(name = "EMPLOYEE")
public class Employee {
   @Id @GeneratedValue
   @Column(name = "id")
   private int id;
}
```

*MappedSuperclass* - позволяет включать класс и его jpa аннотации в производный класс, не делая базовый класс сущностью. Типичное использование в примере выше — абстрактный базовый класс, несущий в себе суррогатный первичный ключ.
В базе данных всё будет выглядеть, как если бы поля базового класса были определены непосредственно в производном классе.

@Embeddable annotation to declare that a class will be embedded by other entities

```java
@Embeddable
public class ContactPerson {
 
    private String firstName;
 
    private String lastName;
 
    private String phone;
 
    // standard getters, setters
}
```

```java
@Entity
public class Company {
 
    @Id
    @GeneratedValue
    private Integer id;
 
    private String name;
 
    private String address;
 
    private String phone;
 
    @Embedded
    private ContactPerson contactPerson;
 
    // standard getters, setters
}
```

As a result, we have our entity Company, embedding contact person details, and mapping to a single database table

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 60 Hibernate

[Hibernate](https://github.com/a11exe/job4j/blob/master/interview_questions/Hibernate.md#hibernate)

ORM - маппинг объектов на БД.
Жизненный цикл Entiity:
+ *Transient:* состояние, при котором объект никогда не был связан с какой-либо сессией и не является персистентностью.
+ *Persistent:* когда объект связан с уникальной сессией он находится в состоянии persistent (персистентности). Любой экземпляр, возвращаемый методами get() или load() находится в состоянии persistent.
+ *Detached:* если объект был персистентным, но сейчас не связан с какой-либо сессией, то он находится в отвязанном (detached) состоянии. Такой объект можно сделать персистентным используя методы update(), saveOrUpdate(), lock() или replicate(). Состояния transient или detached так же могут перейти в состояние persistent как новый объект персистентности после вызова метода merge().
SessionFactory immutable (неизменяемый), то да, он потокобезопасный.

*Session* — это основной интерфейс, который отвечает за связь с базой данных.
+ является оберткой для jdbc подключения к базе данных
+ является фабрикой для транзакций

*Hibernate session* обладает различными методами для загрузки данных из базы данных. Наиболее часто используемые методы для этого — get() и load().
+ get() загружает данные сразу при вызове, в то время как load() использует прокси объект и загружает данные только тогда, когда это требуется на самом деле. В этом плане load() имеет преимущество в плане ленивой загрузки данных.
+ load() бросает исключение, когда данные не найдены. Поэтому его нужно использовать только при уверенности в существовании данных.

flush vs commit
+ flush() синхронизирует вашу базу данных с текущим состоянием объекта/объектов, хранящихся в памяти, но не совершает транзакцию.
+ commit() сделает данные, хранящиеся в базе данных постоянными. Вы не можете отменить свою транзакцию после успешного завершения commit()

*Методы*
+ save() используется для сохранения сущности в базу данных.  немедленно возвращает сгенерированный идентификатор/
+ persist() аналогичен save() с транзакцией. persist() не возвращает сгенерированный идентификатор сразу.
+ saveOrUpdate() использует запрос для вставки или обновления, основываясь на предоставленных данных.
+ merge() может быть использован для обновления существующих значений

In summary  save() method saves records into database by INSERT SQL query, Generates a new identifier and return the Serializable identifier back.
On the other hand  saveOrUpdate() method either INSERT or UPDATE based upon existence of object in database. If persistence object already exists in database then UPDATE SQL will execute and if there is no corresponding object in database than INSERT will run.

save() flushes the entity to the database when you make the call. persist() actually just marks the entity to be persisted in the upcoming flush.
The save method is an “original” Hibernate method. Its purpose is basically the same as persist. 
he call of save on a detached instance creates a new persistent instance and assigns it a new identifier, which results in a duplicate record in a database

*Transaction*
Вместо вызовов session.openTransaction() и session.commit() используется аннотация @Transactional

*Eager vs Lazy*
+ Eager Loading is a design pattern in which data initialization occurs on the spot. Загружаются все данные по цепочке.
+ Lazy Loading is a design pattern which is used to defer initialization of an object as long as it's possible. Данные подгружаются при обращении.

*Named SQL*
Именованные запросы поддерживают как HQL, так и Native SQL.
Создать именованный запрос можно с помощью JPA аннотаций @NamedQuery, @NamedNativeQuery

*Аннотации*
+ *javax.persistence.Entity*: используется для указания класса как entity bean.
+ *javax.persistence.Table*: используется для определения имени таблицы из БД, которая будет отображаться на entity bean.
+ *javax.persistence.Access*: определяет тип доступа, поле или свойство. Поле — является значением по умолчанию и если нужно, чтобы hibernate использовал методы getter/setter, то их необходимо задать для нужного свойства.
+ *javax.persistence.Id*: определяет primary key в entity bean.
+ *javax.persistence.EmbeddedId*: используется для определения составного ключа в бине.
+ *javax.persistence.Column*: определяет имя колонки из таблицы в базе данных.
+ *javax.persistence.GeneratedValue*: задает стратегию создания основных ключей. Используется в сочетании с javax.persistence.GenerationType enum.
+ *javax.persistence.OneToOne*: задает связь один-к-одному между двумя сущностными бинами. Соответственно есть другие аннотации OneToMany, ManyToOne и ManyToMany.
+ *org.hibernate.annotations.Cascade*: определяет каскадную связь между двумя entity бинами. Используется в связке с org.hibernate.annotations.CascadeType.
+ *javax.persistence.PrimaryKeyJoinColumnм: определяет внешний ключ для свойства. Используется вместе с org.hibernate.annotations.GenericGenerator и org.hibernate.annotations.Parameter.

*Criteria API*
```java
Session session = HibernateUtil.getHibernateSession();
CriteriaBuilder cb = session.getCriteriaBuilder();
CriteriaQuery<Item> cr = cb.createQuery(Item.class);
Root<Item> root = cr.from(Item.class);
cr.select(root);
 
Query<Item> query = session.createQuery(cr);
List<Item> results = query.getResultList();
```

*Итоги*
+ Для сохранения сущности следует использовать метод JPA *persist*
+ Для копирования состояния detached-сущности предпочтительным является *merge*
+ Метод update полезен только для задач пакетной обработки.
+ Методы save и saveOrUpdate — это просто псевдонимы для update, и вам не следует использовать их вообще.
+ Некоторые разработчики используют save, даже если объект уже управляется, но это ошибка и вызывает лишнее событие, так как для управляемых сущностей UPDATE автоматически обрабатывается Persistence context во время flush.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 61 Способы аутентификации пользователя

+ *Идентификация* — это заявление о том, кем вы являетесь. В зависимости от ситуации, это может быть имя, адрес электронной почты, номер учетной записи, итд.
+ *Аутентификация* — предоставление доказательств, что вы на самом деле есть тот, кем идентифицировались (от слова “authentic” — истинный, подлинный).
+ *Авторизация* — проверка, что вам разрешен доступ к запрашиваемому ресурсу.

По паролю:
*HTTP authentication*
+ Сервер, при обращении неавторизованного клиента к защищенному ресурсу, отсылает HTTP статус “401 Unauthorized” и добавляет заголовок “WWW-Authenticate” с указанием схемы и параметров аутентификации.
+ Браузер, при получении такого ответа, автоматически показывает диалог ввода username и password. Пользователь вводит детали своей учетной записи.
+ Во всех последующих запросах к этому веб-сайту браузер автоматически добавляет HTTP заголовок “Authorization”, в котором передаются данные пользователя для аутентификации сервером.
+ Сервер аутентифицирует пользователя по данным из этого заголовка. Решение о предоставлении доступа (авторизация) производится отдельно на основании роли пользователя, ACL или других данных учетной записи.

+ Basic — наиболее простая схема, при которой username и password пользователя передаются в заголовке Authorization в незашифрованном виде (base64-encoded). Однако при использовании HTTPS (HTTP over SSL) протокола, является относительно безопасной.
+ Digest — challenge-response-схема, при которой сервер посылает уникальное значение nonce, а браузер передает MD5 хэш пароля пользователя, вычисленный с использованием указанного nonce. Более безопасная альтернативв Basic схемы при незащищенных соединениях, но подвержена man-in-the-middle attacks (с заменой схемы на basic). Кроме того, использование этой схемы не позволяет применить современные хэш-функции для хранения паролей пользователей на сервере.

*Forms authentication*
Работает это по следующему принципу: в веб-приложение включается HTML-форма, 
в которую пользователь должен ввести свои username/password и отправить их на сервер через HTTP POST для аутентификации. 
В случае успеха веб-приложение создает session token, который обычно помещается в browser cookies. 
При последующих веб-запросах session token автоматически передается на сервер и позволяет приложению получить 
информацию о текущем пользователе для авторизации запроса.

Существует всего несколько мест, где можно передать username и password в HTTP запросах:

+ URL query — считается небезопасным вариантом, т. к. строки URL могут запоминаться браузерами, прокси и веб-серверами.
+ Request body — безопасный вариант, но он применим только для запросов, содержащих тело сообщения (такие как POST, PUT, PATCH).
+ HTTP header —оптимальный вариант, при этом могут использоваться и стандартный заголовок Authorization (например, с Basic-схемой), и другие произвольные заголовки.
 

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 62 Паттерны Написать реализацию паттерна Singleton Abstract Factory vs factory method

Factory Method is used to create one product only but Abstract Factory is about creating families of related or dependent products.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 63 How to define immutable object

+ Don't provide "setter" methods — methods that modify fields or objects referred to by fields.
+ Make all fields final and private.
+ Don't allow subclasses to override methods. The simplest way to do this is to declare the class as final. 
A more sophisticated approach is to make the constructor private and construct instances in factory methods.
+ If the instance fields include references to mutable objects, don't allow those objects to be changed:
++ Don't provide methods that modify the mutable objects.
++ Don't share references to the mutable objects. 
Never store references to external, mutable objects passed to the constructor; 
if necessary, create copies, and store references to the copies. 
Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 64 Spring DispatcherServlet how it works

DispatcherServlet acts as front controller for Spring based web applications. 
It provides a mechanism for request processing where actual work is performed by configurable, 
delegate components. It is inherited from javax.servlet.http.HttpServlet, it is typically configured in the web.xml file.

DispatcherServlet uses Spring configuration classes to discover the delegate components it needs for request mapping, view resolution, exception handling etc.

WebApplicationContext is an extension of a plain ApplicationContext. it is web aware ApplicationContext i.e it has Servlet Context information. When DispatcherServlet is loaded, it looks for the bean configuration file of WebApplicationContext and initializes it.

+ An ApplicationContext cannot have more than 1 parent ApplicationContext.
+ When a given ApplicationContext cannot resolve a bean, it will pass on the resolution request to its parent.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 65 Какие существуют два вида методов для работы со стримами

+ *Промежуточные*: filter(), skip(), map(), 
+ *Конечные*: findFirst(), findAny(), collect(), forEach(), count().

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 66 Чем отличается DI от IoC

+ *DI* - связывание объектов. сеттер, конструктор, интерфейс. Все зависимости в 
+ *IoC* - отделить объекты от реализации

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 67 Что такое бин Spring

Любой объект управляемый контейнером.

[к оглавлению](#Вопросы-для-собеседования-минимум)

## 68 Каков жизненный цикл бина Spring

Спринг бины инициализируются при инициализации котейнера. И происходит внедрение зависимостей.
Для выполнения действии перед инициализацией или удалением:
+ @PreDestroy
+ @PostConstruct

[к оглавлению](#Вопросы-для-собеседования-минимум)